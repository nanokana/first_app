<?xml version="1.0" encoding="EUC-JP" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ruby-src:ext/zlib/doc/zlib.rd</title>
<meta http-equiv="Content-type" content="text/html; charset=EUC-JP" />
<link href="default.css" type="text/css" rel="stylesheet" />
<link href="refm526.html" rel="next" />
<link href="refm524.html" rel="prev" />
<link href="index.html" rel="start" />

</head>
<body>
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="index.html">UP</a>][<a href="refm524.html">&lt;-PREV</a>][<a href="refm526.html">NEXT-&gt;</a>]</span></div>
<hr />

<h1><a name="L011647" id="L011647">Ruby/zlib version 0.6.0</a></h1>
<p>Ruby/zlib is an extension library to use zlib from Ruby.
Ruby/zlib also provides the features for accessing gzipped files.</p>
<p>You can modify or redistribute Ruby/zlib in the same manner of
Ruby interpreter. The latest version of Ruby/zlib would be found
at <a href="http://www.blue.sky.or.jp/">&lt;URL:http://www.blue.sky.or.jp/&gt;</a><sup class="outside"><small>[外部]</small></sup>.</p>
<p>Any comments and suggestions are always welcome. Please send
them to ruby-list ML, ruby-ext ML, ruby-talk ML, or the author's
mail address <a href="mailto:katsu@blue.sky.or.jp">&lt;URL:mailto:katsu@blue.sky.or.jp&gt;</a><sup class="outside"><small>[外部]</small></sup>.</p>
<p>This document is experimental and broken English version.
If you find some mistakes or strange expressions (including
kidding or unnatural ones) in this document, please let me know
for my study.</p>
<ul>
<li><a href="refm135.html">Zlib</a>
<ul>
<li><a href="refm136.html">Zlib::Error</a></li>
<li><a href="refm137.html">Zlib::ZStream</a></li>
<li><a href="refm138.html">Zlib::Deflate</a></li>
<li><a href="refm139.html">Zlib::Inflate</a></li>
<li><a href="refm140.html">Zlib::GzipFile</a></li>
<li><a href="refm141.html">Zlib::GzipFile::Error</a></li>
<li><a href="refm142.html">Zlib::GzipWriter</a></li>
<li><a href="refm143.html">Zlib::GzipReader</a></li>
</ul></li>
<li><em class="XXINVALIDXX">Changes from 0.5 to 0.6</em></li>
<li><em class="XXINVALIDXX">Changes from 0.4 to 0.5</em></li>
</ul>
<h2><a name="L011648" id="L011648">Zlib</a></h2>
<p>Zlib is the module which provides the other features in zlib C
library. See zlib.h for detail of each module function.</p>
<h3><a name="L011649" id="L011649">Module Functions:</a></h3>
<dl>
<dt><a name="L011650" id="L011650"><code>Zlib.zlib_version</code></a></dt>
<dd>
<p>Returns the string which represents the version of zlib
library.</p></dd>
<dt><a name="L011651" id="L011651"><code>Zlib.adler32([<var>string</var>[, <var>adler</var>]])</code></a></dt>
<dd>
<p>Calculates Alder-32 checksum for <var>string</var>,
and returns updated value of <var>alder</var>.
If <var>string</var> is omitted, it returns the Adler-32 initial
value. If <var>alder</var> is omitted, it assumes that the initial
value is given to <var>alder</var>.</p></dd>
<dt><a name="L011652" id="L011652"><code>Zlib.crc32([<var>string</var>[, <var>crc</var>]])</code></a></dt>
<dd>
<p>Calculates CRC checksum for <var>string</var>, and returns
updated value of <var>crc</var>. If <var>string</var> is omitted,
it returns the CRC initial value. <var>crc</var> is omitted,
it assumes that the initial value is given to <var>crc</var>.</p></dd>
<dt><a name="L011653" id="L011653"><code>Zlib.crc_table</code></a></dt>
<dd>
<p>Returns the table for calculating CRC checksum as an array.</p></dd>
</dl>
<h3><a name="L011654" id="L011654">Constants:</a></h3>
<dl>
<dt><a name="L011655" id="L011655"><code>Zlib::VERSION</code></a></dt>
<dd>
<p>The Ruby/zlib version string.</p></dd>
<dt><a name="L011656" id="L011656"><code>Zlib::ZLIB_VERSION</code></a></dt>
<dd>
<p>The string which represents the version of zlib.h.</p></dd>
<dt><a name="L011657" id="L011657"><code>Zlib::BINARY</code></a>
<dt><a name="L011658" id="L011658"><code>Zlib::ASCII</code></a>
<dt><a name="L011659" id="L011659"><code>Zlib::UNKNOWN</code></a></dt>
<dd>
<p>The integers representing data types which
<a href="refm137.html#L002659">Zlib::ZStream#data_type</a> method returns.</p></dd>
<dt><a name="L011660" id="L011660"><code>Zlib::NO_COMPRESSION</code></a>
<dt><a name="L011661" id="L011661"><code>Zlib::BEST_SPEED</code></a>
<dt><a name="L011662" id="L011662"><code>Zlib::BEST_COMPRESSION</code></a>
<dt><a name="L011663" id="L011663"><code>Zlib::DEFAULT_COMPRESSION</code></a></dt>
<dd>
<p>The integers representing compression levels which are
an argument for <a href="#L011715">Zlib::Deflate.new</a>,
<a href="refm138.html#L002677">Zlib::Deflate#deflate</a>, and so on.</p></dd>
<dt><a name="L011664" id="L011664"><code>Zlib::FILTERED</code></a>
<dt><a name="L011665" id="L011665"><code>Zlib::HUFFMAN_ONLY</code></a>
<dt><a name="L011666" id="L011666"><code>Zlib::DEFAULT_STRATEGY</code></a></dt>
<dd>
<p>The integers representing compression methods which are
an argument for <a href="#L011715">Zlib::Deflate.new</a> and
<a href="refm138.html#L002681">Zlib::Deflate#params</a>.</p></dd>
<dt><a name="L011667" id="L011667"><code>Zlib::DEF_MEM_LEVEL</code></a>
<dt><a name="L011668" id="L011668"><code>Zlib::MAX_MEM_LEVEL</code></a></dt>
<dd>
<p>The integers representing memory levels which are an
argument for <a href="#L011715">Zlib::Deflate.new</a>,
<a href="refm138.html#L002681">Zlib::Deflate#params</a>, and so on.</p></dd>
<dt><a name="L011669" id="L011669"><code>Zlib::MAX_WBITS</code></a></dt>
<dd>
<p>The default value of <var>windowBits</var> which is an argument for
<a href="#L011715">Zlib::Deflate.new</a> and <a href="#L011725">Zlib::Inflate.new</a>.</p></dd>
<dt><a name="L011670" id="L011670"><code>Zlib::NO_FLUSH</code></a>
<dt><a name="L011671" id="L011671"><code>Zlib::SYNC_FLUSH</code></a>
<dt><a name="L011672" id="L011672"><code>Zlib::FULL_FLUSH</code></a>
<dt><a name="L011673" id="L011673"><code>Zlib::FINISH</code></a></dt>
<dd>
<p>The integers to control the output of the deflate stream,
which are an argument for <a href="refm138.html#L002677">Zlib::Deflate#deflate</a> and so on.</p></dd>
<dt><a name="L011674" id="L011674"><code>Zlib::OS_CODE</code></a>
<dt><a name="L011675" id="L011675"><code>Zlib::OS_MSDOS</code></a>
<dt><a name="L011676" id="L011676"><code>Zlib::OS_AMIGA</code></a>
<dt><a name="L011677" id="L011677"><code>Zlib::OS_VMS</code></a>
<dt><a name="L011678" id="L011678"><code>Zlib::OS_UNIX</code></a>
<dt><a name="L011679" id="L011679"><code>Zlib::OS_VMCMS</code></a>
<dt><a name="L011680" id="L011680"><code>Zlib::OS_ATARI</code></a>
<dt><a name="L011681" id="L011681"><code>Zlib::OS_OS2</code></a>
<dt><a name="L011682" id="L011682"><code>Zlib::OS_MACOS</code></a>
<dt><a name="L011683" id="L011683"><code>Zlib::OS_ZSYSTEM</code></a>
<dt><a name="L011684" id="L011684"><code>Zlib::OS_CPM</code></a>
<dt><a name="L011685" id="L011685"><code>Zlib::OS_TOPS20</code></a>
<dt><a name="L011686" id="L011686"><code>Zlib::OS_WIN32</code></a>
<dt><a name="L011687" id="L011687"><code>Zlib::OS_QDOS</code></a>
<dt><a name="L011688" id="L011688"><code>Zlib::OS_RISCOS</code></a>
<dt><a name="L011689" id="L011689"><code>Zlib::OS_UNKNOWN</code></a></dt>
<dd>
<p>The return values of <a href="refm140.html#L002710">Zlib::GzipFile#os_code</a> method.</p></dd>
</dl>
<h2><a name="L011690" id="L011690">Zlib::Error</a></h2>
<p>The superclass for all exceptions raised by Ruby/zlib.</p>
<p>The following exceptions are defined as subclasses of Zlib::Error.
These exceptions are raised when zlib library functions return
with an error status.</p>
<ul>
<li>Zlib::StreamEnd</li>
<li>Zlib::NeedDict</li>
<li>Zlib::DataError</li>
<li>Zlib::StreamError</li>
<li>Zlib::MemError</li>
<li>Zlib::BufError</li>
<li>Zlib::VersionError</li>
</ul>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li>StandardError</li>
</ul>
<h2><a name="L011692" id="L011692">Zlib::ZStream</a></h2>
<p>The abstract class for the stream which handles the compressed
data. The operations are defined in the subclasses,
<a href="refm138.html">Zlib::Deflate</a> for compression, and <a href="refm139.html">Zlib::Inflate</a>
for decompression.</p>
<p>An instance of Zlib::ZStream has one stream (struct zstream) and
two variable-length buffers which associated to the input
(next_in) of the stream and the output (next_out) of the stream.
In this document, &quot;input buffer&quot; means the buffer for input, and
&quot;output buffer&quot; means the buffer for output.</p>
<p>Data inputed into an instance of Zlib::ZStream are temporally
stored into the end of input buffer, and then data in input buffer
are processed from the beginning of the buffer until no more
output from the stream is produced (i.e. until avail_out &gt; 0
after processing). During processing, output buffer is allocated
and expanded automatically to hold all output data.</p>
<p>Some particular instance methods consume the data in output buffer
and return them as a String.</p>
<p>Here is an ascii art for describing above:</p>
<pre>+================ an instance of Zlib::ZStream ================+
||                                                            ||
||     +--------+          +-------+          +--------+      ||
||  +--| output |&lt;---------|zstream|&lt;---------| input  |&lt;--+  ||
||  |  | buffer |  next_out+-------+next_in   | buffer |   |  ||
||  |  +--------+                             +--------+   |  ||
||  |                                                      |  ||
+===|======================================================|===+
    |                                                      |
    v                                                      |
&quot;output data&quot;                                         &quot;input data&quot;</pre>
<p>If an error is occurred during processing input buffer,
an exception which is a subclass of <a href="refm136.html">Zlib::Error</a> is raised.
At that time, both input and output buffer keeps their conditions
at the time when the error is occurred.</p>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li>Object</li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011694" id="L011694"><code>Zlib::ZStream.new</code></a></dt>
<dd>
<p>See <a href="#L011715">Zlib::Deflate.new</a> and <a href="#L011725">Zlib::Inflate.new</a>.</p></dd>
</dl>
<h3><a name="L011695" id="L011695">Methods:</a></h3>
<dl>
<dt><a name="L011696" id="L011696"><code>Zlib::ZStream#avail_in</code></a></dt>
<dd>
<p>Returns bytes of data in input buffer.
Normally, returns 0.</p></dd>
<dt><a name="L011697" id="L011697"><code>Zlib::ZStream#avail_out</code></a></dt>
<dd>
<p>Returns bytes of free spaces in output buffer.
Because the free spaces are allocated automatically,
this method returns 0 normally.</p></dd>
<dt><a name="L011698" id="L011698"><code>Zlib::ZStream#avail_out = <var>size</var></code></a></dt>
<dd>
<p>Allocates free spaces of <var>size</var> bytes in output buffer.
If there are more than <var>size</var> bytes spaces in the buffer,
the buffer is truncated.
Because the free spaces are allocated automatically,
you usually need not to use this method.</p></dd>
<dt><a name="L011699" id="L011699"><code>Zlib::ZStream#flush_next_in</code></a></dt>
<dd>
<p>Flushes input buffer and returns all data in that buffer.</p></dd>
<dt><a name="L011700" id="L011700"><code>Zlib::ZStream#flush_next_out</code></a></dt>
<dd>
<p>Flushes output buffer and returns all data in that buffer.</p></dd>
<dt><a name="L011701" id="L011701"><code>Zlib::ZStream#total_in</code></a></dt>
<dd>
<p>Returns the total bytes of the input data to the stream.</p></dd>
<dt><a name="L011702" id="L011702"><code>Zlib::ZStream#total_out</code></a></dt>
<dd>
<p>Returns the total bytes of the output data from the stream.</p></dd>
<dt><a name="L011703" id="L011703"><code>Zlib::ZStream#data_type</code></a></dt>
<dd>
<p>Guesses the type of the data which have been inputed into
the stream. The returned value is either <a href="refm135.html#L002610">Zlib::BINARY</a>,
<a href="refm135.html#L002611">Zlib::ASCII</a>, or <a href="refm135.html#L002612">Zlib::UNKNOWN</a>.</p></dd>
<dt><a name="L011704" id="L011704"><code>Zlib::ZStream#adler</code></a></dt>
<dd>
<p>Returns the alder-32 checksum.</p></dd>
<dt><a name="L011705" id="L011705"><code>Zlib::ZStream#reset</code></a></dt>
<dd>
<p>Resets and initializes the stream. All data in both
input and output buffer are discarded.</p></dd>
<dt><a name="L011706" id="L011706"><code>Zlib::ZStream#finish</code></a></dt>
<dd>
<p>Finishes the stream and flushes output buffer.
See <a href="refm138.html#L002680">Zlib::Deflate#finish</a> and <a href="refm139.html#L002691">Zlib::Inflate#finish</a>
for detail of the behavior.</p></dd>
<dt><a name="L011707" id="L011707"><code>Zlib::ZStream#finished?</code></a>
<dt><a name="L011708" id="L011708"><code>Zlib::ZStream#stream_end?</code></a></dt>
<dd>
<p>Returns true if the stream is finished.</p></dd>
<dt><a name="L011709" id="L011709"><code>Zlib::ZStream#close</code></a>
<dt><a name="L011710" id="L011710"><code>Zlib::ZStream#end</code></a></dt>
<dd>
<p>Closes the stream. All operations on the closed stream
will raise an exception.</p></dd>
<dt><a name="L011711" id="L011711"><code>Zlib::ZStream#closed?</code></a>
<dt><a name="L011712" id="L011712"><code>Zlib::ZStream#ended?</code></a></dt>
<dd>
<p>Returns true if the stream closed.</p></dd>
</dl>
<h2><a name="L011713" id="L011713">Zlib::Deflate</a></h2>
<p>The class for compressing string data.</p>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li><a href="refm137.html">Zlib::ZStream</a></li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011714" id="L011714"><code>Zlib::Deflate.deflate(<var>string</var>[, <var>level</var>])</code></a></dt>
<dd>
<p>Compresses <var>string</var>. The avail values of <var>level</var> are
<a href="refm135.html#L002613">Zlib::NO_COMPRESSION</a>, <a href="refm135.html#L002614">Zlib::BEST_SPEED</a>,
<a href="refm135.html#L002615">Zlib::BEST_COMPRESSION</a>, <a href="refm135.html#L002616">Zlib::DEFAULT_COMPRESSION</a>,
and the integer from 0 to 9.</p>
<p>This method is almost equivalent to the following code:</p>
<pre>def deflate(string, level)
  z = Zlib::Deflate.new(level)
  dst = z.deflate(string, Zlib::FINISH)
  z.close
  dst
end</pre></dd>
<dt><a name="L011715" id="L011715"><code>Zlib::Deflate.new([<var>level</var>[, <var>windowBits</var>[, <var>memlevel</var>[, <var>strategy</var>]]]])</code></a></dt>
<dd>
<p>Creates a new deflate stream for compression.
See zlib.h for details of each argument.
If an argument is nil, the default value of that
argument is used.</p></dd>
</dl>
<h3><a name="L011695" id="L011695">Methods:</a></h3>
<dl>
<dt><a name="L011716" id="L011716"><code>Zlib::Deflate#clone</code></a></dt>
<dd>
<p>Duplicates the deflate stream.</p></dd>
<dt><a name="L011717" id="L011717"><code>Zlib::Deflate#deflate(<var>string</var>[, <var>flush</var>])</code></a></dt>
<dd>
<p>Inputs <var>string</var> into the deflate stream and returns
the output from the stream. Calling this method,
both input and output buffer of the stream are flushed.
If <var>string</var> is nil, this method finishes the stream,
just like <a href="refm137.html#L002662">Zlib::ZStream#finish</a>.
The value of <var>flush</var> should be either <a href="refm135.html#L002623">Zlib::NO_FLUSH</a>,
<a href="refm135.html#L002624">Zlib::SYNC_FLUSH</a>, <a href="refm135.html#L002625">Zlib::FULL_FLUSH</a>, or
<a href="refm135.html#L002626">Zlib::FINISH</a>.
See zlib.h for details.</p></dd>
<dt><a name="L011718" id="L011718"><code>Zlib::Deflate#&lt;&lt; <var>string</var></code></a></dt>
<dd>
<p>Inputs <var>string</var> into the deflate stream just like
<a href="refm138.html#L002677">Zlib::Deflate#deflate</a>, but returns Zlib::Deflate object
itself. The output from the stream is preserved in output
buffer.</p></dd>
<dt><a name="L011719" id="L011719"><code>Zlib::Deflate#flush([<var>flush</var>])</code></a></dt>
<dd>
<p>This method is equivalent to <code>deflate('', <var>flush</var>)</code>.
If <var>flush</var> is omitted, <a href="refm135.html#L002624">Zlib::SYNC_FLUSH</a> is used
as <var>flush</var>. This method is just provided for
readability of your Ruby script.</p></dd>
<dt><a name="L011720" id="L011720"><code>Zlib::Deflate#finish</code></a></dt>
<dd>
<p>Finishes the stream. This method is equivalent to
<code>deflate('', Zlib::FINISH)</code>.</p></dd>
<dt><a name="L011721" id="L011721"><code>Zlib::Deflate#params(<var>level</var>, <var>strategy</var>)</code></a></dt>
<dd>
<p>Changes the parameters of the deflate stream.
See zlib.h for details. The output from the stream
by changing the params is preserved in output buffer.</p></dd>
<dt><a name="L011722" id="L011722"><code>Zlib::Deflate#set_dictionary(<var>string</var>)</code></a></dt>
<dd>
<p>Sets the preset dictionary and returns <var>string</var>.
This method is available just only after
<a href="#L011715">Zlib::Deflate.new</a> or <a href="refm137.html#L002661">Zlib::ZStream#reset</a> method
was called. See zlib.h for details.</p></dd>
</dl>
<h2><a name="L011723" id="L011723">Zlib::Inflate</a></h2>
<p>The class for decompressing compressed data.
Unlike <a href="refm138.html">Zlib::Deflate</a>, an instance of this class is not able
to duplicate (clone, dup) itself.</p>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li><a href="refm137.html">Zlib::ZStream</a></li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011724" id="L011724"><code>Zlib::Inflate.inflate(<var>string</var>)</code></a></dt>
<dd>
<p>Decompresses <var>string</var>. Raises a <em class="XXINVALIDXX">Zlib::NeedDict</em>
exception if a preset dictionary is needed for decompression.</p>
<p>This method is almost equivalent to the following code:</p>
<pre>def inflate(string)
  zstream = Zlib::Inflate.new
  buf = zstream.inflate(string)
  zstream.finish
  zstream.close
  buf
end</pre></dd>
<dt><a name="L011725" id="L011725"><code>Zlib::Inflate.new([<var>windowBits</var>])</code></a></dt>
<dd>
<p>Creates a new inflate stream for decompression.
See zlib.h for details of the argument.
If <var>windowBits</var> is nil, the default value is used.</p></dd>
</dl>
<h3><a name="L011695" id="L011695">Methods:</a></h3>
<dl>
<dt><a name="L011726" id="L011726"><code>Zlib::Inflate#inflate(<var>string</var>)</code></a></dt>
<dd>
<p>Inputs <var>string</var> into the inflate stream and returns
the output from the stream. Calling this method,
both input and output buffer of the stream are flushed.
If <var>string</var> is nil, this method finishes the stream,
just like <a href="refm137.html#L002662">Zlib::ZStream#finish</a>.</p>
<p>Raises a <em class="XXINVALIDXX">Zlib::NeedDict</em> exception if a preset
dictionary is needed to decompress. Set the dictionary
by <a href="refm139.html#L002692">Zlib::Inflate#set_dictionary</a> and then call
this method again with an empty string.</p></dd>
<dt><a name="L011727" id="L011727"><code>Zlib::Inflate#&lt;&lt; <var>string</var></code></a></dt>
<dd>
<p>Inputs <var>string</var> into the inflate stream just like
<a href="#L011726">Zlib::Inflate#inflate</a>, but returns Zlib::Inflate object
itself. The output from the stream is preserved in output
buffer.</p></dd>
<dt><a name="L011728" id="L011728"><code>Zlib::Inflate#finish</code></a></dt>
<dd>
<p>Finishes the inflate stream and returns the garbage
following the compressed data. Raises an exception
if the stream is not finished
(i.e. <a href="refm137.html#L002663">Zlib::ZStream#finished?</a> doesn't returns true).</p>
<p>The inflate stream finishes itself as soon as it meets
the end code of the compressed data, you need not to call
this method explicitly. However, this method is useful
for checking whether the data is correctly ended or not.</p></dd>
<dt><a name="L011729" id="L011729"><code>Zlib::Inflate#set_dictionary(<var>string</var>)</code></a></dt>
<dd>
<p>Sets the preset dictionary and returns <var>string</var>
This method is available just only after a <em class="XXINVALIDXX">Zlib::NeedDict</em>
exception was raised. See zlib.h for details.</p></dd>
<dt><a name="L011730" id="L011730"><code>Zlib::Inflate#sync(<var>string</var>)</code></a></dt>
<dd>
<p>Inputs <var>string</var> into the end of input buffer and
skips data until a full flush point can be found.
If the point is found in the buffer, this method flushes
the buffer and returns false. Otherwise it returns true
and the following data of full flush point is preserved
in the buffer.</p></dd>
<dt><a name="L011731" id="L011731"><code>Zlib::Inflate#sync_point?</code></a></dt>
<dd>
<p>What is this?</p></dd>
</dl>
<h2><a name="L011732" id="L011732">Zlib::GzipFile</a></h2>
<p>The abstract class for handling a gzip formatted compressed file.
The operations are defined in the subclasses,
<a href="refm143.html">Zlib::GzipReader</a> for reading, and <a href="refm142.html">Zlib::GzipWriter</a>
for writing.</p>
<p>GzipReader should be used with associating an instance of IO class
(or an object which has the same methods as IO has).</p>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li>Object</li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011733" id="L011733"><code>Zlib::GzipFile.new(<var>args</var>...)</code></a></dt>
<dd>
<p>See <a href="#L011754">Zlib::GzipReader.new</a> and <a href="#L011778">Zlib::GzipWriter.new</a>.</p></dd>
<dt><a name="L011734" id="L011734"><code>Zlib::GzipFile.wrap(<var>args</var>...) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>See <a href="#L011755">Zlib::GzipReader.wrap</a> and <a href="#L011779">Zlib::GzipWriter.wrap</a>.</p></dd>
<dt><a name="L011735" id="L011735"><code>Zlib::GzipFile.open(<var>args</var>...) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>See <a href="#L011756">Zlib::GzipReader.open</a> and <a href="#L011780">Zlib::GzipWriter.open</a>.</p></dd>
</dl>
<h3><a name="L011695" id="L011695">Methods:</a></h3>
<dl>
<dt><a name="L011736" id="L011736"><code>Zlib::GzipFile#closed?</code></a>
<dt><a name="L011737" id="L011737"><code>Zlib::GzipFile#to_io</code></a></dt>
<dd>
<p>Same as IO.</p></dd>
<dt><a name="L011738" id="L011738"><code>Zlib::GzipFile#close</code></a></dt>
<dd>
<p>Closes the GzipFile object. This method calls close method
of the associated IO object. Returns the associated IO object.</p></dd>
<dt><a name="L011739" id="L011739"><code>Zlib::GzipFile#finish</code></a></dt>
<dd>
<p>Closes the GzipFile object. Unlike <a href="refm140.html#L002705">Zlib::GzipFile#close</a>,
this method <em>never</em> calls close method of the associated IO
object. Returns the associated IO object.</p></dd>
<dt><a name="L011740" id="L011740"><code>Zlib::GzipFile#crc</code></a></dt>
<dd>
<p>Returns CRC value of the uncompressed data.</p></dd>
<dt><a name="L011741" id="L011741"><code>Zlib::GzipFile#level</code></a></dt>
<dd>
<p>Returns compression level.</p></dd>
<dt><a name="L011742" id="L011742"><code>Zlib::GzipFile#mtime</code></a></dt>
<dd>
<p>Returns last modification time recorded in the gzip
file header.</p></dd>
<dt><a name="L011743" id="L011743"><code>Zlib::GzipFile#os_code</code></a></dt>
<dd>
<p>Returns OS code number recorded in the gzip file header.</p></dd>
<dt><a name="L011744" id="L011744"><code>Zlib::GzipFile#orig_name</code></a></dt>
<dd>
<p>Returns original filename recorded in the gzip file header,
or nil if original filename is not present.</p></dd>
<dt><a name="L011745" id="L011745"><code>Zlib::GzipFile#comment</code></a></dt>
<dd>
<p>Returns comments recorded in the gzip file header, or
nil if the comments is not present.</p></dd>
<dt><a name="L011746" id="L011746"><code>Zlib::GzipFile#sync</code></a>
<dt><a name="L011747" id="L011747"><code>Zlib::GzipFile#sync= <var>flag</var></code></a></dt>
<dd>
<p>Same as IO. If <var>flag</var> is true, the associated IO object
must respond to flush method. While `sync' mode is true,
the compression ratio decreases sharply.</p></dd>
</dl>
<h2><a name="L011748" id="L011748">Zlib::GzipFile::Error</a></h2>
<p>The superclass for all exceptions raised during processing a gzip
file.</p>
<p>The following exceptions are defined as subclasses of
Zlib::GzipFile::Error.</p>
<dl>
<dt><a name="L011749" id="L011749">Zlib::GzipFile::NoFooter</a></dt>
<dd>
<p>Raised when gzip file footer has not found.</p>
</dd>
<dt><a name="L011750" id="L011750">Zlib::GzipFile::CRCError</a></dt>
<dd>
<p>Raised when the CRC checksum recorded in gzip file footer
is not equivalent to CRC checksum of the actually
uncompressed data.</p>
</dd>
<dt><a name="L011751" id="L011751">Zlib::GzipFile::LengthError</a></dt>
<dd>
<p>Raised when the data length recorded in gzip file footer
is not equivalent to length of the actually uncompressed data.</p>
</dd>
</dl>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li><a href="refm136.html">Zlib::Error</a></li>
</ul>
<h2><a name="L011752" id="L011752">Zlib::GzipReader</a></h2>
<p>The class for reading a gzipped file. GzipReader should be used
with associating an instance of IO class (or an object which has
the same methods as IO has).</p>
<pre>Zlib::GzipReader.open('hoge.gz') {|gz|
  print gz.read
}

f = File.open('hoge.gz')
gz = Zlib::GzipReader.new(f)
print gz.read
gz.close</pre>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li><a href="refm140.html">Zlib::GzipFile</a></li>
</ul>
<h3><a name="L011753" id="L011753">Included Modules:</a></h3>
<ul>
<li>Enumerable</li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011754" id="L011754"><code>Zlib::GzipReader.new(<var>io</var>)</code></a></dt>
<dd>
<p>Creates a GzipReader object associated with <var>io</var>.
The GzipReader object reads gzipped data from <var>io</var>,
and parses/decompresses them. At least, <var>io</var> must have
read method that behaves same as read method in IO class.</p>
<p>If the gzip file header is incorrect, raises an
<a href="refm141.html">Zlib::GzipFile::Error</a> exception.</p></dd>
<dt><a name="L011755" id="L011755"><code>Zlib::GzipReader.wrap(<var>io</var>) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>Creates a GzipReader object associated with <var>io</var>, and
executes the block with the newly created GzipReader object,
just like File::open. The GzipReader object will be closed
automatically after executing the block. If you want to keep
the associated IO object opening, you may call
<a href="refm140.html#L002706">Zlib::GzipFile#finish</a> method in the block.</p></dd>
<dt><a name="L011756" id="L011756"><code>Zlib::GzipReader.open(<var>filename</var>)</code></a>
<dt><a name="L011757" id="L011757"><code>Zlib::GzipReader.open(<var>filename</var>) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>Opens a file specified by <var>filename</var> as a gzipped file,
and returns a GzipReader object associated with that file.
Further details of this method are same as
<a href="#L011754">Zlib::GzipReader.new</a> and <em class="XXINVALIDXX">ZLib::GzipReader.wrap</em>.</p></dd>
</dl>
<h3><a name="L011758" id="L011758">メソッド:</a></h3>
<dl>
<dt><a name="L011759" id="L011759"><code>Zlib::GzipReader#eof</code></a>
<dt><a name="L011760" id="L011760"><code>Zlib::GzipReader#eof?</code></a></dt>
<dd>
<p>Returns true if the object reaches the end of compressed data.
Note that eof? does <em>not</em> return true when reaches the
end of <em>file</em>.</p></dd>
<dt><a name="L011761" id="L011761"><code>Zlib::GzipReader#pos</code></a>
<dt><a name="L011762" id="L011762"><code>Zlib::GzipReader#tell</code></a></dt>
<dd>
<p>Returns the total bytes of data decompressed until now.
Not that it does <em>not</em> the position of file pointer.</p></dd>
<dt><a name="L011763" id="L011763"><code>Zlib::GzipReader#each([<var>rs</var>])</code></a>
<dt><a name="L011764" id="L011764"><code>Zlib::GzipReader#each_line([<var>rs</var>])</code></a>
<dt><a name="L011765" id="L011765"><code>Zlib::GzipReader#each_byte([<var>rs</var>])</code></a>
<dt><a name="L011766" id="L011766"><code>Zlib::GzipReader#gets([<var>rs</var>])</code></a>
<dt><a name="L011767" id="L011767"><code>Zlib::GzipReader#getc</code></a>
<dt><a name="L011768" id="L011768"><code>Zlib::GzipReader#lineno</code></a>
<dt><a name="L011769" id="L011769"><code>Zlib::GzipReader#lineno=</code></a>
<dt><a name="L011770" id="L011770"><code>Zlib::GzipReader#read([<var>length</var>])</code></a>
<dt><a name="L011771" id="L011771"><code>Zlib::GzipReader#readchar</code></a>
<dt><a name="L011772" id="L011772"><code>Zlib::GzipReader#readline([<var>rs</var>])</code></a>
<dt><a name="L011773" id="L011773"><code>Zlib::GzipReader#readlines([<var>rs</var>])</code></a>
<dt><a name="L011774" id="L011774"><code>Zlib::GzipReader#ungetc(<var>char</var>)</code></a></dt>
<dd>
<p>Same as IO, but raises <a href="refm136.html">Zlib::Error</a> or
<a href="refm141.html">Zlib::GzipFile::Error</a> exception if an error was found
in the gzip file.</p>
<p>Be careful of the footer of gzip file. A gzip file has
the checksum of pre-compressed data in its footer.
GzipReader checks all uncompressed data against that checksum
at the following cases, and if failed, raises
<a href="refm141.html#L002717">Zlib::GzipFile::NoFooter</a>, <a href="refm141.html#L002718">Zlib::GzipFile::CRCError</a>,
or <a href="refm141.html#L002719">Zlib::GzipFile::LengthError</a> exception.</p>
<ul>
<li>When an reading request is received beyond the end of file
      (the end of compressed data).
      That is, when <a href="refm143.html#L002765">Zlib::GzipReader#read</a>,
      <a href="refm143.html#L002761">Zlib::GzipReader#gets</a>, or some other methods for reading
      returns nil.</li>
<li>When <a href="refm140.html#L002705">Zlib::GzipFile#close</a> method is called after
      the object reaches the end of file.</li>
<li>When <a href="refm143.html#L002772">Zlib::GzipReader#unused</a> method is called after
      the object reaches the end of file.</li>
</ul></dd>
<dt><a name="L011775" id="L011775"><code>Zlib::GzipReader#rewind</code></a></dt>
<dd>
<p>Resets the position of the file pointer to the point
created the GzipReader object.
The associated IO object need to respond to seek method.</p></dd>
<dt><a name="L011776" id="L011776"><code>Zlib::GzipReader#unused</code></a></dt>
<dd>
<p>Returns the rest of the data which had read for parsing gzip
format, or nil if the whole gzip file is not parsed yet.</p></dd>
</dl>
<h2><a name="L011777" id="L011777">Zlib::GzipWriter</a></h2>
<p>The class for writing a gzipped file. GzipWriter should be used
with associate with an instance of IO class (or an object which
has the same methods as IO has).</p>
<pre>Zlib::GzipWriter.open('hoge.gz') {|gz|
  gz.write 'jugemu jugemu gokou no surikire...'
}

f = File.open('hoge.gz', 'w')
gz = Zlib::GzipWriter.new(f)
gz.write 'jugemu jugemu gokou no surikire...'
gz.close</pre>
<p>NOTE: Due to the limitation in finalizer of Ruby, you must close
explicitly GzipWriter object by <a href="refm142.html#L002730">Zlib::GzipWriter#close</a> etc.
Otherwise, GzipWriter should be not able to write gzip footer and
generate broken gzip file.</p>
<h3><a name="L011691" id="L011691">SuperClass:</a></h3>
<ul>
<li><a href="refm140.html">Zlib::GzipFile</a></li>
</ul>
<h3><a name="L011693" id="L011693">Class Methods:</a></h3>
<dl>
<dt><a name="L011778" id="L011778"><code>Zlib::GzipWriter.new(<var>io</var>[, <var>level</var>[, <var>strategy</var>]])</code></a></dt>
<dd>
<p>Creates a GzipWriter object associated with <var>io</var>.
<var>level</var> and <var>strategy</var> should be same as the
arguments of <a href="#L011715">Zlib::Deflate.new</a>. The GzipWriter object
writes gzipped data to <var>io</var>. At least, <var>io</var> must
respond to write method that behaves same as write method
in IO class.</p></dd>
<dt><a name="L011779" id="L011779"><code>Zlib::GzipWriter.wrap(<var>io</var>[, <var>level</var>[, <var>strategy</var>]]) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>Creates a GzipWriter object associated with <var>io</var>, and
executes the block with the newly created GzipWriter object,
just like File::open. The GzipWriter object will be closed
automatically after executing the block. If you want to keep
the associated IO object opening, you may call
<a href="refm140.html#L002706">Zlib::GzipFile#finish</a> method in the block.</p></dd>
<dt><a name="L011780" id="L011780"><code>Zlib::GzipWriter.open(<var>filename</var>[, <var>level</var>[, <var>strategy</var>]])</code></a>
<dt><a name="L011781" id="L011781"><code>Zlib::GzipWriter.open(<var>filename</var>[, <var>level</var>[, <var>strategy</var>]]) {|<var>gz</var>| ... }</code></a></dt>
<dd>
<p>Opens a file specified by <var>filename</var> for writing
gzip compressed data, and returns a GzipWriter object
associated with that file. Further details of this method
are same as <a href="#L011778">Zlib::GzipWriter.new</a> and
<em class="XXINVALIDXX">Zlib::GzipWriter#wrap</em>.</p></dd>
</dl>
<h3><a name="L011695" id="L011695">Methods:</a></h3>
<dl>
<dt><a name="L011782" id="L011782"><code>Zlib::GzipWriter#close</code></a>
<dt><a name="L011783" id="L011783"><code>Zlib::GzipWriter#finish</code></a></dt>
<dd>
<p>Closes the GzipFile object. This method calls close method
of the associated IO object. Returns the associated IO object.
See <a href="refm140.html#L002705">Zlib::GzipFile#close</a> and <a href="refm140.html#L002706">Zlib::GzipFile#finish</a>
for the difference between close and finish.</p>
<p><em>NOTE: Due to the limitation in finalizer of Ruby, you must
close GzipWriter object explicitly. Otherwise, GzipWriter
should be not able to write gzip footer and generate broken
gzip file.</em></p></dd>
<dt><a name="L011784" id="L011784"><code>Zlib::GzipWriter#pos</code></a>
<dt><a name="L011785" id="L011785"><code>Zlib::GzipWriter#tell</code></a></dt>
<dd>
<p>Returns the total bytes of data compressed until now.
Note that it does <em>not</em> the position of file pointer.</p></dd>
<dt><a name="L011786" id="L011786"><code>Zlib::GzipWriter#&lt;&lt; <var>str</var></code></a>
<dt><a name="L011787" id="L011787"><code>Zlib::GzipWriter#putc(<var>ch</var>)</code></a>
<dt><a name="L011788" id="L011788"><code>Zlib::GzipWriter#puts(<var>obj</var>...)</code></a>
<dt><a name="L011789" id="L011789"><code>Zlib::GzipWriter#print(<var>arg</var>...)</code></a>
<dt><a name="L011790" id="L011790"><code>Zlib::GzipWriter#printf(<var>format</var>, <var>arg</var>...)</code></a>
<dt><a name="L011791" id="L011791"><code>Zlib::GzipWriter#write(<var>str</var>)</code></a></dt>
<dd>
<p>Same as IO.</p></dd>
<dt><a name="L011792" id="L011792"><code>Zlib::GzipWriter#flush([<var>flush</var>])</code></a></dt>
<dd>
<p>Flushes all the internal buffers of the GzipWriter object.
The meaning of <var>flush</var> is same as one of the argument of
<a href="refm138.html#L002677">Zlib::Deflate#deflate</a>.
<a href="refm135.html#L002624">Zlib::SYNC_FLUSH</a> is used if <var>flush</var> is omitted.
It is no use giving <var>flush</var> <a href="refm135.html#L002623">Zlib::NO_FLUSH</a>.</p></dd>
<dt><a name="L011793" id="L011793"><code>Zlib::GzipWriter#mtime= <var>time</var></code></a></dt>
<dd>
<p>Sets last modification time to be stored in the gzip file
header. <a href="refm141.html">Zlib::GzipFile::Error</a> exception will be raised
if this method is called after writing method (like
<a href="refm142.html#L002739">Zlib::GzipWriter#write</a>) was called.</p></dd>
<dt><a name="L011794" id="L011794"><code>Zlib::GzipWriter#orig_name= <var>filename</var></code></a></dt>
<dd>
<p>Sets original filename to be stored in the gzip file header.
<a href="refm141.html">Zlib::GzipFile::Error</a> exception will be raised
if this method is called after writing method (like
<a href="refm142.html#L002739">Zlib::GzipWriter#write</a>) was called.</p></dd>
<dt><a name="L011795" id="L011795"><code>Zlib::GzipWriter#comment= <var>string</var></code></a></dt>
<dd>
<p>Sets comments to be stored in the gzip file header.
<a href="refm141.html">Zlib::GzipFile::Error</a> exception will be raised
if this method is called after writing method (like
<a href="refm142.html#L002739">Zlib::GzipWriter#write</a>) was called.</p></dd>
</dl>
<h2><a name="L011796" id="L011796">Changes from 0.5 to 0.6</a></h2>
<ul>
<li>New methods:
<ul>
<li><a href="#L011734">Zlib::GzipFile.wrap</a></li>
<li><a href="refm140.html#L002706">Zlib::GzipFile#finish</a></li>
</ul></li>
<li>New constants:
<ul>
<li><a href="refm135.html#L002609">Zlib::ZLIB_VERSION</a></li>
<li><a href="refm135.html#L002632">Zlib::OS_VMCMS</a></li>
<li><a href="refm135.html#L002636">Zlib::OS_ZSYSTEM</a></li>
<li><a href="refm135.html#L002637">Zlib::OS_CPM</a></li>
<li><a href="refm135.html#L002640">Zlib::OS_QDOS</a></li>
<li><a href="refm135.html#L002641">Zlib::OS_RISCOS</a></li>
<li><a href="refm135.html#L002642">Zlib::OS_UNKNOWN</a></li>
</ul></li>
<li>Changed methods:
<ul>
<li><a href="#L011733">Zlib::GzipFile.new</a> now takes no block. Use
    <a href="#L011734">Zlib::GzipFile.wrap</a> instead.</li>
<li><a href="refm140.html#L002705">Zlib::GzipFile#close</a> now takes no argument. Use
    <a href="refm140.html#L002706">Zlib::GzipFile#finish</a> instead.</li>
</ul></li>
<li>Renamed methods:
<ul>
<li>Zlib.version is renamed to <a href="refm135.html#L002603">Zlib.zlib_version</a>.</li>
</ul></li>
<li>Changed constants:
<ul>
<li><a href="refm135.html#L002608">Zlib::VERSION</a> indicates the version of Ruby/zlib.
    The zlib.h version is now in <a href="refm135.html#L002609">Zlib::ZLIB_VERSION</a>.</li>
</ul></li>
<li>Backward compatibility:
<ul>
<li>For backward compatibility for 0.5, the obsoleted methods and
    arguments are still available.</li>
<li>Obsoleted classes, methods, and constants for backward
    compatibility for 0.4 or earlier are removed.</li>
</ul></li>
</ul>
<h2><a name="L011797" id="L011797">Changes from 0.4 to 0.5</a></h2>
<p>Almost all the code are rewritten.
I hope all changes are enumerated below :-)</p>
<ul>
<li>The names of almost classes and some methods are changed.
  All classes and constants are now defined under module
  <a href="refm135.html">Zlib</a>. The obsoleted names are also available for backward
  compatibility.
<ul>
<li>Classes
<ul>
<li>Deflate -&gt; <a href="refm138.html">Zlib::Deflate</a></li>
<li>Inflate -&gt; <a href="refm139.html">Zlib::Inflate</a></li>
<li>Zlib::Gzip -&gt; <a href="refm140.html">Zlib::GzipFile</a></li>
<li>GzipReader -&gt; <a href="refm143.html">Zlib::GzipReader</a></li>
<li>GzipWriter -&gt; <a href="refm142.html">Zlib::GzipWriter</a></li>
<li>Zlib::Gzip::Error -&gt; <a href="refm141.html">Zlib::GzipFile::Error</a></li>
<li>Zlib::GzipReader::NoFooter -&gt; <a href="refm141.html#L002717">Zlib::GzipFile::NoFooter</a></li>
<li>Zlib::GzipReader::CRCError -&gt; <a href="refm141.html#L002718">Zlib::GzipFile::CRCError</a></li>
<li>Zlib::GzipReader::LengthError -&gt; <a href="refm141.html#L002719">Zlib::GzipFile::LengthError</a></li>
</ul></li>
<li>Constants
<ul>
<li>Zlib::ZStream::BINARY -&gt; <a href="refm135.html#L002610">Zlib::BINARY</a></li>
<li>Zlib::ZStream::ASCII -&gt; <a href="refm135.html#L002611">Zlib::ASCII</a></li>
<li>Zlib::ZStream::UNKNOWN -&gt; <a href="refm135.html#L002612">Zlib::UNKNOWN</a></li>
<li>Zlib::Deflate::NO_COMPRESSION -&gt; <a href="refm135.html#L002613">Zlib::NO_COMPRESSION</a></li>
<li>Zlib::Deflate::BEST_SPEED -&gt; <a href="refm135.html#L002614">Zlib::BEST_SPEED</a></li>
<li>Zlib::Deflate::BEST_COMPRESSION -&gt; <a href="refm135.html#L002615">Zlib::BEST_COMPRESSION</a></li>
<li>Zlib::Deflate::DEFAULT_COMPRESSION -&gt; <a href="refm135.html#L002616">Zlib::DEFAULT_COMPRESSION</a></li>
<li>Zlib::Deflate::FILTERED -&gt; <a href="refm135.html#L002617">Zlib::FILTERED</a></li>
<li>Zlib::Deflate::HUFFMAN_ONLY -&gt; <a href="refm135.html#L002618">Zlib::HUFFMAN_ONLY</a></li>
<li>Zlib::Deflate::DEFAULT_STRATEGY -&gt; <a href="refm135.html#L002619">Zlib::DEFAULT_STRATEGY</a></li>
<li>Zlib::Deflate::MAX_WBITS -&gt; <a href="refm135.html#L002622">Zlib::MAX_WBITS</a></li>
<li>Zlib::Deflate::DEF_MEM_LEVEL -&gt; <a href="refm135.html#L002620">Zlib::DEF_MEM_LEVEL</a></li>
<li>Zlib::Deflate::MAX_MEM_LEVEL -&gt; <a href="refm135.html#L002621">Zlib::MAX_MEM_LEVEL</a></li>
<li>Zlib::Deflate::NO_FLUSH -&gt; <a href="refm135.html#L002623">Zlib::NO_FLUSH</a></li>
<li>Zlib::Deflate::SYNC_FLUSH -&gt; <a href="refm135.html#L002624">Zlib::SYNC_FLUSH</a></li>
<li>Zlib::Deflate::FULL_FLUSH -&gt; <a href="refm135.html#L002625">Zlib::FULL_FLUSH</a></li>
<li>Zlib::Inflate::MAX_WBITS -&gt; <a href="refm135.html#L002622">Zlib::MAX_WBITS</a></li>
<li>Zlib::GzipReader::OS_* -&gt; <a href="refm135.html#L002627">Zlib::OS_*</a></li>
</ul></li>
<li>Methods
<ul>
<li>Zlib::ZStream#flush_out -&gt; <a href="refm137.html#L002656">Zlib::ZStream#flush_next_out</a></li>
</ul></li>
</ul></li>
<li>Made buffer for input (next_in).</li>
<li><a href="refm143.html#L002772">Zlib::GzipReader#unused</a> returns nil after closing.</li>
<li>Now you are up to call <a href="refm142.html#L002730">Zlib::GzipWriter#close</a> explicitly</li>
</ul>
<p>to avoid segv in finalizer.
<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-dev/11915">[ruby-dev:11915]</a><sup class="outside"><small>[外部]</small></sup></p>
<ul>
<li>divided initialize from new.</li>
<li>remove sanity checks for arguments for deflateInit2 and
  inflateInit2.</li>
<li>adapted the behavior of <a href="refm142.html#L002736">Zlib::GzipWriter#puts</a> to Ruby-1.7.</li>
<li>Made all functions static.</li>
</ul>

<hr />
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="index.html">UP</a>][<a href="refm524.html">&lt;-PREV</a>][<a href="refm526.html">NEXT-&gt;</a>]</span></div>

</body>
</html>
