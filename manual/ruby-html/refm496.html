<?xml version="1.0" encoding="EUC-JP" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>parse.y</title>
<meta http-equiv="Content-type" content="text/html; charset=EUC-JP" />
<link href="default.css" type="text/css" rel="stylesheet" />
<link href="refm497.html" rel="next" />
<link href="refm495.html" rel="prev" />
<link href="index.html" rel="start" />

</head>
<body>
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="refm488.html">UP</a>][<a href="refm495.html">&lt;-PREV</a>][<a href="refm497.html">NEXT-&gt;</a>]</span></div>
<hr />

<h1><a name="L010420" id="L010420">parse.y</a></h1>
<dl>
<dt><a name="L010421" id="L010421">static NODE *arg_add(NODE *node1, NODE *node2)</a></dt>
<dt><a name="L010422" id="L010422">static void arg_ambiguous(void)</a></dt>
<dd>
<p>メソッド引数の括弧が省略され、最初の引数の一文字目が
演算子とも解釈できる場合に警告を出します。</p>
</dd>
<dt><a name="L010423" id="L010423">static NODE *arg_blk_pass(NODE *node1, NODE *node2)</a></dt>
<dt><a name="L010424" id="L010424">static NODE *arg_concat(NODE *node1, NODE *node2)</a></dt>
<dt><a name="L010425" id="L010425">static NODE *arg_prepend(NODE *node1, NODE *node2)</a></dt>
<dt><a name="L010426" id="L010426">static NODE *aryset(NODE *recv, NODE *idx)</a></dt>
<dt><a name="L010427" id="L010427">static int assign_in_cond(NODE *node)</a></dt>
<dd>
<p>条件式中の代入に警告を出します。</p>
</dd>
<dt><a name="L010428" id="L010428">static NODE *assignable(ID id, NODE *val)</a></dt>
<dt><a name="L010429" id="L010429">static NODE *attrset(NODE *recv, ID id)</a></dt>
<dt><a name="L010430" id="L010430">static NODE *block_append(NODE *head, NODE *tail)</a></dt>
<dd>
<p><var>head</var> と <var>tail</var> を <code>NODE_BLOCK</code> のリストとして連結し、
先頭ノードを返します。<var>head</var> または <var>tail</var> が <code>NODE_BLOCK</code>
でない場合は <code>NODE_BLOCK</code> に入れたうえでそれを連結します。
<var>head</var> もしくは <var>tail</var> が <code>NULL</code> なら連結はせず、
<code>NULL</code> でないほうを返します。</p>
</dd>
<dt><a name="L010431" id="L010431">static NODE *call_op(NODE *recv, ID id, int narg, NODE *arg1)</a></dt>
<dt><a name="L010432" id="L010432">static NODE *cond(NODE *node)</a></dt>
<dt><a name="L010433" id="L010433">static NODE *cond0(NODE *node)</a></dt>
<dt><a name="L010434" id="L010434">static int dyna_in_block(void)</a></dt>
<dd>
<p>ブロックにネストしているコードをパース中は真。</p>
</dd>
<dt><a name="L010435" id="L010435">static void dyna_pop(struct RVarmap *vars)</a></dt>
<dd>
<p>ブロックローカル変数テーブルをポップします。</p>
</dd>
<dt><a name="L010436" id="L010436">static struct RVarmap *dyna_push(void)</a></dt>
<dd>
<p>ブロックローカル変数テーブルをプッシュします。</p>
</dd>
<dt><a name="L010437" id="L010437">static int e_option_supplied(void)</a></dt>
<dd>
<p>ruby -e で与えたプログラムを実行中なら真。</p>
</dd>
<dt><a name="L010438" id="L010438">static void fixpos(NODE *node, NODE *orig)</a></dt>
<dd>
<p><var>orig</var> に格納されているファイル名と行番号を <var>node</var> にコピーします。
<var>node</var> もしくは <var>orig</var> が <code>NULL</code> のときは何もしません。</p>
</dd>
<dt><a name="L010439" id="L010439">static NODE *gettable(ID id)</a></dt>
<dd>
<p><var>id</var> が変数・定数として有効ならば、それを参照するノードを返します。
(get + able であって get table ではない)</p>
</dd>
<dt><a name="L010440" id="L010440">static int here_document(NODE *here)</a></dt>
<dd>
<p>lex_strterm 形式の term に従ってヒアドキュメントを
終端行まで読み込む。</p>
</dd>
<dt><a name="L010441" id="L010441">static int heredoc_identifier(void)</a></dt>
<dd>
<p>ヒアドキュメントの「&lt;&lt;」を既に読みこんだものと仮定して
開始記号を読みこみ、<code>lex_strterm</code> をセットします。
返り値は、読み込みに成功したときはシンボル、解析できないときは 0 です。</p>
</dd>
<dt><a name="L010442" id="L010442">static void heredoc_restore(NODE *here)</a></dt>
<dd>
<p>ヒアドキュメントの本体の読み込みに失敗したとき、開始記号
のある行を復帰します。<var>here</var> は <code>lex_strterm</code> です。</p>
</dd>
<dt><a name="L010443" id="L010443">void Init_sym(void)</a></dt>
<dd>
<p>シンボル関係の変数を初期化します。</p>
</dd>
<dt><a name="L010444" id="L010444">static ID internal_id(void)</a></dt>
<dd>
<p>インタプリタ内部でだけ使う、
他のものとは重複しない <code>ID</code> を返します。</p>
</dd>
<dt><a name="L010445" id="L010445">static VALUE lex_get_str(VALUE s)</a></dt>
<dd>
<p>文字列 <var>s</var> の <code>lex_gets_ptr</code> の後から一行取得し、返します。
<code>lex_gets_ptr</code> も進められます。</p>
</dd>
<dt><a name="L010446" id="L010446">static VALUE lex_getline(void)</a></dt>
<dd>
<p>関数 <code>lex_gets</code> を使って <code>lex_input</code> から
Ruby プログラムを一行読みこみます。</p>
</dd>
<dt><a name="L010447" id="L010447">static NODE *list_append(NODE *head, NODE *tail)</a></dt>
<dd>
<p><code>NODE_LIST</code> のリスト <var>head</var> に非 <code>NODE_LIST</code> のノード
<var>tail</var> を連結し、先頭ノードを返します。<var>head</var> が <code>NULL</code>
のときは <var>tail</var> を <code>NODE_LIST</code> でラップして返します。</p>
</dd>
<dt><a name="L010448" id="L010448">static NODE *list_concat(NODE *head, NODE *tail)</a></dt>
<dd>
<p>NODE_LISTのリストheadにNODE_LISTのノードtailを連結し、
先頭ノードを返す。head、tailともにNULLであってはならない。</p>
</dd>
<dt><a name="L010449" id="L010449">static NODE *literal_append(NODE *head, NODE *tail)</a></dt>
<dt><a name="L010450" id="L010450">static NODE *literal_concat(NODE *head, NODE *tail)</a></dt>
<dt><a name="L010451" id="L010451">static NODE *literal_concat_dstr(NODE *head, NODE *tail)</a></dt>
<dt><a name="L010452" id="L010452">static NODE *literal_concat_list(NODE *head, NODE *tail)</a></dt>
<dt><a name="L010453" id="L010453">static NODE *literal_concat_string(NODE *head, NODE *tail, VALUE str)</a></dt>
<dt><a name="L010454" id="L010454">static int local_append(ID id)</a></dt>
<dd>
<p>新しいローカル変数 <var>id</var> をテーブルに追加します。</p>
</dd>
<dt><a name="L010455" id="L010455">static int local_cnt(ID id)</a></dt>
<dd>
<p>ローカル変数 <var>id</var> の変数 ID を取得します。
定義されていてもいなくても正しい ID が取得できます。</p>
</dd>
<dt><a name="L010456" id="L010456">static int local_id(ID id)</a></dt>
<dd>
<p>現在のスコープでローカル変数 id が定義されていれば真。</p>
</dd>
<dt><a name="L010457" id="L010457">static void local_pop(void)</a></dt>
<dd>
<p>ローカル変数テーブルをポップします。
テーブルが参照されていない場合、
テーブルは自動的に開放されます。</p>
</dd>
<dt><a name="L010458" id="L010458">static void local_push(int top)</a></dt>
<dd>
<p>ローカル変数テーブルをプッシュします。
プログラムのトップレベルをパースしているときは <var>top</var> を真にします。</p>
</dd>
<dt><a name="L010459" id="L010459">static ID *local_tbl(void)</a></dt>
<dd>
<p>ローカル変数テーブルスタックの先頭にあるテーブルを取得します。</p>
</dd>
<dt><a name="L010460" id="L010460">static NODE *logop(enum node_type type, NODE *left, NODE *right)</a></dt>
<dt><a name="L010461" id="L010461">static NODE *match_gen(NODE *node1, NODE *node2)</a></dt>
<dt><a name="L010462" id="L010462">static NODE *new_call(NODE *r, ID m, NODE *a)</a></dt>
<dt><a name="L010463" id="L010463">static NODE *new_fcall(ID m, NODE *a)</a></dt>
<dt><a name="L010464" id="L010464">static NODE *new_super(NODE *a)</a></dt>
<dt><a name="L010465" id="L010465">static NODE *newline_node(NODE *node)</a></dt>
<dd>
<p>nodeがNULLでなければ現在パース中の行番号を格納した
NODE_NEWLINEをnodeの前にに付加し、それを返す。</p>
</dd>
<dt><a name="L010466" id="L010466">static char *newtok(void)</a></dt>
<dd>
<p>トークンバッファを初期化またはクリアし、
次のトークンを開始する。</p>
</dd>
<dt><a name="L010467" id="L010467">static int nextc(void)</a></dt>
<dd>
<p>入力から次の一文字を読み込みます。
CR LF に対して LF を、EOF に対して -1 を返します。</p>
</dd>
<dt><a name="L010468" id="L010468">static NODE *node_assign(NODE *lhs, NODE *rhs)</a></dt>
<dt><a name="L010469" id="L010469">static int nodeline(NODE *node)</a></dt>
<dd>
<p><var>node</var> に埋め込まれている行番号を返します。
デバッグ用です。</p>
</dd>
<dt><a name="L010470" id="L010470">static enum node_type nodetype(node)</a></dt>
<dd>
<p><var>node</var> の種類を返します。
デバッグ用です。</p>
</dd>
<dt><a name="L010471" id="L010471">static int parse_string(NODE *quote)</a></dt>
<dd>
<p>lex_strterm 形式のノード <var>quote</var> の指示に従い、
文字列の終端または埋め込み式の始まりまで読みこみます。</p>
</dd>
<dt><a name="L010472" id="L010472">int peek(int c) [macro]</a></dt>
<dd>
<p>現在読み込み中のプログラムの次の文字が <var>c</var> ならば真。</p>
</dd>
<dt><a name="L010473" id="L010473">static void pushback(int c)</a></dt>
<dd>
<p>入力に一文字戻します。
<var>c</var> が EOF (-1) のときはなにもしません。</p>
</dd>
<dt><a name="L010474" id="L010474">static NODE *range_op(NODE *node)</a></dt>
<dt><a name="L010475" id="L010475">static void rb_backref_error(NODE *node)</a></dt>
<dt><a name="L010476" id="L010476">VALUE rb_backref_get(void)</a></dt>
<dd>
<p>現在の SCOPE の <code>$~</code> の値を返します。</p>
</dd>
<dt><a name="L010477" id="L010477">void rb_backref_set(VALUE val)</a></dt>
<dd>
<p>現在の SCOPE の <code>$~</code> に <var>val</var> を代入します。</p>
</dd>
<dt><a name="L010478" id="L010478">NODE *rb_compile_cstr(const char *f, const char *s, int len, int line)</a></dt>
<dd>
<p>C の文字列 <var>s</var> を構文木にコンパイルし、<code>ruby_eval_tree</code> と
<code>ruby_eval_tree_begin</code> に格納します。<code>ruby_eval_tree</code> を返します。
またコンパイルするときにファイル <var>f</var> の <var>line</var> 行目からをコンパイル
していると仮定します。</p>
</dd>
<dt><a name="L010479" id="L010479">NODE *rb_compile_file(const char *f, VALUE file, int start)</a></dt>
<dd>
<p>Ruby の IO オブジェクト <var>file</var> から文字列を読み込み、
それを Ruby プログラムとして構文木にコンパイルします。
作成した構文木は <code>ruby_eval_tree</code> と <code>ruby_eval_tree_begin</code> に
格納し、同時に <code>ruby_eval_tree</code> を返します。
またコンパイルするときにファイル <var>f</var> の <var>line</var> 行目からをコンパイル
していると仮定します。</p>
</dd>
<dt><a name="L010480" id="L010480">NODE *rb_compile_string(const char *f, VALUE s, int line)</a></dt>
<dd>
<p>Ruby の文字列 <var>s</var> を構文木にコンパイルし、<code>ruby_eval_tree</code> と
<code>ruby_eval_tree_begin</code> に格納します。<code>ruby_eval_tree</code> を返します。
またコンパイルするときにファイル <var>f</var> の <var>line</var> 行目からをコンパイル
していると仮定します。</p>
</dd>
<dt><a name="L010481" id="L010481">char *rb_id2name(ID id)</a></dt>
<dd>
<p><code>id</code> に対応する文字列を返します。
返り値は開放できません。</p>
</dd>
<dt><a name="L010482" id="L010482">ID rb_id_attrset(ID id)</a></dt>
<dt><a name="L010483" id="L010483">ID rb_intern(const char *name)</a></dt>
<dd>
<p>任意の char* と一対一に対応する整数 <code>ID</code> を返す。</p>
</dd>
<dt><a name="L010484" id="L010484">int rb_is_class_id(ID id)</a></dt>
<dd>
<p>クラス変数名として有効な <code>ID</code> ならば真。</p>
</dd>
<dt><a name="L010485" id="L010485">int rb_is_const_id(ID id)</a></dt>
<dd>
<p>定数名として有効な <code>ID</code> ならば真。</p>
</dd>
<dt><a name="L010486" id="L010486">int rb_is_instance_id(ID id)</a></dt>
<dd>
<p>インスタンス変数名として有効な <code>ID</code> ならば真。</p>
</dd>
<dt><a name="L010487" id="L010487">int rb_is_local_id(ID id)</a></dt>
<dd>
<p>ローカル変数名として有効な <code>ID</code> ならば真。</p>
</dd>
<dt><a name="L010488" id="L010488">VALUE rb_lastline_get(void)</a></dt>
<dd>
<p>現在評価中の <code>SCOPE</code> の <code>$_</code> の値を取得します。</p>
</dd>
<dt><a name="L010489" id="L010489">void rb_lastline_set(VALUE val)</a></dt>
<dd>
<p>現在評価中の <code>SCOPE</code> の <code>$_</code> に <var>val</var> を代入します。</p>
</dd>
<dt><a name="L010490" id="L010490">NODE *rb_node_newnode(enum node_type type, NODE *a0, NODE *a1, NODE *a2)</a></dt>
<dd>
<p>ノードタイプが <var>type</var> で <var>a0 a1 a2</var> を
要素に持つノードを生成し、返します。</p>
</dd>
<dt><a name="L010491" id="L010491">void rb_parser_append_print(void)</a></dt>
<dd>
<p>ruby の -p オプションの実装。
ループと print のノードを ruby_eval_tree に加えます。</p>
</dd>
<dt><a name="L010492" id="L010492">void rb_parser_while_loop(int chop, int split)</a></dt>
<dd>
<p>ruby の -n オプションの実装。
ループと print のノードを ruby_eval_tree に加えます。</p>
</dd>
<dt><a name="L010493" id="L010493">static struct kwtable *rb_reserved_word(const char *str, unsigned int len)</a></dt>
<dd>
<p>長さ <var>len</var> の文字列 <var>str</var> が予約語であれば
そのフラグテーブルを返します。<var>str</var> が予約語でなければ
<code>NULL</code> を返します。</p>
<pre>struct kwtable {
    char *name;            /* 予約語の名前 */
    int id[2];             /* 0:  非修飾型シンボル
                              1:  修飾型シンボル (kIF_MOD など) があれば
                                  それを格納する。なければ id[0] と同じ  */
    enum lex_state state;  /* 遷移すべきlex_state */
};</pre>
</dd>
<dt><a name="L010494" id="L010494">VALUE rb_sym_all_symbols(void)</a></dt>
<dd>
<p>呼び出し時までに変換が行われたすべてのシンボルの
配列を返す。</p>
</dd>
<dt><a name="L010495" id="L010495">static int read_escape(void)</a></dt>
<dd>
<p>一文字に相当するバックスラッシュ記法が許す
文字列を入力バッファから読みとり、評価値を返す。
先頭のバックスラッシュはすでに読みこんでいるものと仮定する。
不正な記法に対してはyyerrorを呼び出し0を返す。</p>
</dd>
<dt><a name="L010496" id="L010496">static int regx_options(void)</a></dt>
<dd>
<p>正規表現のオプション (ixmo nesu) を読み込み
フラグ (ビットマスク) を返します。</p>
</dd>
<dt><a name="L010497" id="L010497">static NODE *ret_args(NODE *node)</a></dt>
<dt><a name="L010498" id="L010498">static void special_local_set(char c, VALUE val)</a></dt>
<dd>
<p>$~ と $_ をセットします。
現在は c=0 が $_ で c=1 が $~ です。</p>
</dd>
<dt><a name="L010499" id="L010499">static int symbols_i(char *key, ID value, VALUE ary)</a></dt>
<dd>
<p>rb_sym_all_symbols() のイテレータブロック。</p>
</dd>
<dt><a name="L010500" id="L010500">char *tok(void) [macro]</a></dt>
<dd>
<p>現在のトークンの先頭へのポインタ。
free してはならない。</p>
</dd>
<dt><a name="L010501" id="L010501">static void tokadd(char c)</a></dt>
<dd>
<p>トークンバッファに文字 <var>c</var> を追加します。</p>
</dd>
<dt><a name="L010502" id="L010502">static int tokadd_escape(int term)</a></dt>
<dd>
<p>文字列・正規表現中で許されるバックスラッシュ記法を
入力バッファから読みとり、トークンバッファに追加します。
先頭のバックスラッシュはすでに読みこんでいるものと仮定します。
不正な記法に対しては <code>yyerror</code> を呼び出し 0 を返します。</p>
</dd>
<dt><a name="L010503" id="L010503">static int tokadd_string(int func, int term, int paren)</a></dt>
<dt><a name="L010504" id="L010504">void tokfix(void) [macro]</a></dt>
<dd>
<p>トークンバッファを NUL で終端します。</p>
</dd>
<dt><a name="L010505" id="L010505">toklast(void) [macro]</a></dt>
<dd>
<p>現在のトークンの末尾へのポインタ。</p>
</dd>
<dt><a name="L010506" id="L010506">int toklen(void) [macro]</a></dt>
<dd>
<p>現在のトークンの長さ。</p>
</dd>
<dt><a name="L010507" id="L010507">static void top_local_init(void)</a></dt>
<dd>
<p>パース中のプログラムのトップレベルのためのローカル変数テーブルをプッシュする。</p>
</dd>
<dt><a name="L010508" id="L010508">static void top_local_setup(void)</a></dt>
<dd>
<p>パース中のプログラムのトップレベルのためのローカル変数テーブルをポップし、
現在存在する SCOPE にそれを接ぎ足す。</p>
</dd>
<dt><a name="L010509" id="L010509">static int value_expr(NODE *node)</a></dt>
<dd>
<p><var>node</var> を評価したときに、確実に値が得られない式が
あるならば警告またはエラーにする。</p>
</dd>
<dt><a name="L010510" id="L010510">static void void_expr(NODE *node)</a></dt>
<dd>
<p><var>node</var> の表すプログラムの中に値を使わないと
意味のない式があれば警告を出す。</p>
<pre># 警告が出る例
lvar = 1
lvar      # 無駄
p lvar</pre>
</dd>
<dt><a name="L010511" id="L010511">static void void_stmts(NODE *node)</a></dt>
<dd>
<p><var>node</var> の表すプログラムの中に値を使わないと
意味のない式があれば警告を出す。</p>
<pre># 警告が出る例
lvar = 1
lvar      # 無駄
p lvar</pre>
</dd>
<dt><a name="L010512" id="L010512">static void warn_unless_e_option(const char *str)</a></dt>
<dd>
<p>ruby -e で与えたプログラムの評価中ではないなら、
警告メッセージ <var>str</var> を出力する。</p>
</dd>
<dt><a name="L010513" id="L010513">static void warning_unless_e_option(const char *str)</a></dt>
<dd>
<p>ruby -e で与えたプログラムの評価中ではなく、
しかも <code>$VERBOSE</code> が真ならば、警告メッセージ <var>str</var> を出力する。</p>
</dd>
<dt><a name="L010514" id="L010514">static int whole_match_p(char *eos, int len, int indent)</a></dt>
<dd>
<p>現在の入力行がヒアドキュメントの終端記号であれば真。</p>
</dd>
<dt><a name="L010515" id="L010515">static NODE *yycompile(char *f, int line)</a></dt>
<dd>
<p>コンパイルを開始します。そのとき、
ファイル名 <var>f</var> の <var>line</var> 行目からを
コンパイルするものと仮定します。</p>
</dd>
<dt><a name="L010516" id="L010516">static int yyerror(char *msg)</a></dt>
<dd>
<p>パースエラーを報告するときに <code>yyparse</code> から呼び出されます。
エラーメッセージ <var>msg</var> とエラーになった場所を出力して 0 を返します。</p>
</dd>
<dt><a name="L010517" id="L010517">static int yylex(void)</a></dt>
<dd>
<p><code>yyparse</code> から呼び出されるスキャンルーチンです。
次のトークンを読み込み、そのシンボルを返します。</p>
</dd>
<dt><a name="L010518" id="L010518">static int yyparse(void)</a></dt>
<dd>
<p>パースを開始します。
この関数は yacc が自動的に生成するので <code>parse.y</code> には存在しません。</p>
</dd>
</dl>

<hr />
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="refm488.html">UP</a>][<a href="refm495.html">&lt;-PREV</a>][<a href="refm497.html">NEXT-&gt;</a>]</span></div>

</body>
</html>
