<?xml version="1.0" encoding="EUC-JP" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ruby-src:README.EXT.ja</title>
<meta http-equiv="Content-type" content="text/html; charset=EUC-JP" />
<link href="default.css" type="text/css" rel="stylesheet" />
<link href="refm534.html" rel="next" />
<link href="refm532.html" rel="prev" />
<link href="index.html" rel="start" />

</head>
<body>
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="index.html">UP</a>][<a href="refm532.html">&lt;-PREV</a>][<a href="refm534.html">NEXT-&gt;</a>]</span></div>
<hr />

<h1>ruby-src:README.EXT.ja</h1>
.\&quot;&nbsp;README.EXT.ja&nbsp;-&nbsp;&nbsp;-*-&nbsp;Text&nbsp;-*-&nbsp;created&nbsp;at:&nbsp;Mon&nbsp;Aug&nbsp;&nbsp;7&nbsp;16:45:54&nbsp;JST&nbsp;1995<br />
<br />
Rubyの拡張ライブラリの作り方を説明します．<br />
<br />
1．基礎知識<br />
<br />
Cの変数には型があり，データには型がありません．ですから，た<br />
とえばポインタをintの変数に代入すると，その値は整数として取<br />
り扱われます．逆にRubyの変数には型がなく，データに型がありま<br />
す．この違いのため，CとRubyは相互に変換しなければ，お互いの<br />
データをアクセスできません．<br />
<br />
RubyのデータはVALUEというCの型で表現されます．VALUE型のデー<br />
タはそのデータタイプを自分で知っています．このデータタイプと<br />
いうのはデータ(オブジェクト)の実際の構造を意味していて，Ruby<br />
のクラスとはまた違ったものです．<br />
<br />
VALUEからCにとって意味のあるデータを取り出すためには<br />
<br />
&nbsp;(1)&nbsp;VALUEのデータタイプを知る<br />
&nbsp;(2)&nbsp;VALUEをCのデータに変換する<br />
<br />
の両方が必要です．(1)を忘れると間違ったデータの変換が行われ<br />
て，最悪プログラムがcore&nbsp;dumpします．<br />
<br />
1.1&nbsp;データタイプ<br />
<br />
Rubyにはユーザが使う可能性のある以下のタイプがあります．<br />
<br />
&nbsp;&nbsp;T_NIL&nbsp;&nbsp;nil<br />
&nbsp;&nbsp;T_OBJECT&nbsp;通常のオブジェクト<br />
&nbsp;&nbsp;T_CLASS&nbsp;&nbsp;クラス<br />
&nbsp;&nbsp;T_MODULE&nbsp;モジュール<br />
&nbsp;&nbsp;T_FLOAT&nbsp;&nbsp;浮動小数点数<br />
&nbsp;&nbsp;T_STRING&nbsp;文字列<br />
&nbsp;&nbsp;T_REGEXP&nbsp;正規表現<br />
&nbsp;&nbsp;T_ARRAY&nbsp;&nbsp;配列<br />
&nbsp;&nbsp;T_FIXNUM&nbsp;Fixnum(31bit長整数)<br />
&nbsp;&nbsp;T_HASH&nbsp;&nbsp;連想配列<br />
&nbsp;&nbsp;T_STRUCT&nbsp;(Rubyの)構造体<br />
&nbsp;&nbsp;T_BIGNUM&nbsp;多倍長整数<br />
&nbsp;&nbsp;T_FILE&nbsp;&nbsp;入出力<br />
&nbsp;&nbsp;T_TRUE&nbsp;&nbsp;真<br />
&nbsp;&nbsp;T_FALSE&nbsp;&nbsp;偽<br />
&nbsp;&nbsp;T_DATA&nbsp;&nbsp;データ<br />
&nbsp;&nbsp;T_SYMBOL&nbsp;シンボル<br />
<br />
その他に内部で利用されている以下のタイプがあります．<br />
<br />
&nbsp;&nbsp;T_ICLASS<br />
&nbsp;&nbsp;T_MATCH<br />
&nbsp;&nbsp;T_UNDEF<br />
&nbsp;&nbsp;T_VARMAP<br />
&nbsp;&nbsp;T_SCOPE<br />
&nbsp;&nbsp;T_NODE<br />
<br />
ほとんどのタイプはCの構造体で実装されています．<br />
<br />
1.2&nbsp;VALUEのデータタイプをチェックする<br />
<br />
ruby.hではTYPE()というマクロが定義されていて，VALUEのデータ<br />
タイプを知ることが出来ます．TYPE()マクロは上で紹介したT_XXXX<br />
の形式の定数を返します．VALUEのデータタイプに応じて処理する<br />
場合には，TYPE()の値で分岐することになります．<br />
<br />
&nbsp;&nbsp;switch&nbsp;(TYPE(obj))&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;T_FIXNUM:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;FIXNUMの処理&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;T_STRING:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文字列の処理&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;T_ARRAY:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;配列の処理&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
&nbsp;&nbsp;&nbsp;&nbsp;default:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;例外を発生させる&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rb_raise(rb_eTypeError,&nbsp;&quot;not&nbsp;valid&nbsp;value&quot;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />
&nbsp;&nbsp;}<br />
<br />
それとデータタイプをチェックして，正しくなければ例外を発生す<br />
る関数が用意されています．<br />
<br />
&nbsp;&nbsp;void&nbsp;Check_Type(VALUE&nbsp;value,&nbsp;int&nbsp;type)<br />
<br />
この関数はvalueがtypeで無ければ，例外を発生させます．引数と<br />
して与えられたVALUEのデータタイプが正しいかどうかチェックす<br />
るためには，この関数を使います．<br />
<br />
FIXNUMとNILに関してはより高速な判別マクロが用意されています．<br />
<br />
&nbsp;&nbsp;FIXNUM_P(obj)<br />
&nbsp;&nbsp;NIL_P(obj)<br />
<br />
1.3&nbsp;VALUEをCのデータに変換する<br />
<br />
データタイプがT_NIL,&nbsp;T_FALSE,&nbsp;T_TRUEである時，データはそれぞ<br />
れnil,&nbsp;false,&nbsp;trueです．このデータタイプのオブジェクトはひと<br />
つずつしか存在しません．<br />
<br />
データタイプがT_FIXNUMの時，これは31bitのサイズを持つ整数で<br />
す．FIXNUMをCの整数に変換するためにはマクロ「FIX2INT()」を使<br />
います．それから，FIXNUMに限らずRubyのデータを整数に変換する<br />
「NUM2INT()」というマクロがあります．このマクロはデータタイ<br />
プのチェック無しで使えます(整数に変換できない場合には例外が<br />
発生する)．同様にチェック無しで使える変換マクロはdoubleを<br />
取り出す「NUM2DBL()」があります。<br />
<br />
char*&nbsp;を取り出す場合、version&nbsp;1.6&nbsp;以前では「STR2CSTR()」と<br />
いうマクロを使っていましたが、これは&nbsp;to_str()&nbsp;による暗黙の<br />
型変換結果が&nbsp;GC&nbsp;される可能性があるため、version&nbsp;1.7&nbsp;以降では<br />
obsolete&nbsp;となり、代わりに&nbsp;StringValue()&nbsp;と&nbsp;StringValuePtr()<br />
を使う事を推奨しています。StringValue(var)&nbsp;は&nbsp;var&nbsp;が&nbsp;String<br />
&nbsp;であれば何もせず、そうでなければ&nbsp;var&nbsp;を&nbsp;var.to_str()&nbsp;の結果に<br />
置き換えるマクロ、StringValuePtr(var)&nbsp;は同様に&nbsp;var&nbsp;を置き換え<br />
てから&nbsp;var&nbsp;の文字列表現に対する&nbsp;char*&nbsp;を返すマクロです。var&nbsp;の<br />
内容を直接置き換える処理が入るので、var&nbsp;は&nbsp;lvalue&nbsp;である必要が<br />
あります。<br />
<br />
それ以外のデータタイプは対応するCの構造体があります．対応す<br />
る構造体のあるVALUEはそのままキャスト(型変換)すれば構造体の<br />
ポインタに変換できます．<br />
<br />
構造体は「struct&nbsp;RXxxxx」という名前でruby.hで定義されていま<br />
す．例えば文字列は「struct&nbsp;RString」です．実際に使う可能性が<br />
あるのは文字列と配列くらいだと思います．<br />
<br />
ruby.hでは構造体へキャストするマクロも「RXXXXX()」(全部大文<br />
字にしたもの)という名前で提供されています(例:&nbsp;RSTRING())．<br />
<br />
構造体からデータを取り出すマクロが提供されています。文字列<br />
strの長さを得るためには「RSTRING_LEN(str)」とし，文字列strを<br />
char*として得るためには「RSTRING_PTR(str)」とします．配列の<br />
場合には，それぞれ「RARRAY_LEN(ary)」，「RARRAY_PTR(ary)」と<br />
なります．<br />
<br />
Rubyの構造体を直接アクセスする時に気をつけなければならないこ<br />
とは，配列や文字列の構造体の中身は参照するだけで，直接変更し<br />
ないことです．直接変更した場合，オブジェクトの内容の整合性が<br />
とれなくなって，思わぬバグの原因になります．<br />
<br />
1.4&nbsp;CのデータをVALUEに変換する<br />
<br />
VALUEの実際の構造は<br />
<br />
&nbsp;&nbsp;*&nbsp;FIXNUMの場合<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;1bit左シフトして，LSBを立てる．<br />
<br />
&nbsp;&nbsp;*&nbsp;その他のポインタの場合<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;そのままVALUEにキャストする．<br />
<br />
となっています．よって，LSBをチェックすればVALUEがFIXNUMかど<br />
うかわかるわけです(ポインタのLSBが立っていないことを仮定して<br />
いる)．<br />
<br />
ですから，FIXNUM以外のRubyのオブジェクトの構造体は単にVALUE<br />
にキャストするだけでVALUEに変換出来ます．ただし，任意の構造<br />
体がVALUEにキャスト出来るわけではありません．キャストするの<br />
はRubyの知っている構造体(ruby.hで定義されているstruct&nbsp;RXxxx<br />
のもの)だけです．<br />
<br />
FIXNUMに関しては変換マクロを経由する必要があります．Cの整数<br />
からVALUEに変換するマクロは以下のものがあります．必要に応じ<br />
て使い分けてください．<br />
<br />
&nbsp;&nbsp;INT2FIX()&nbsp;&nbsp;もとの整数が31bit以内に収まる自信がある時<br />
&nbsp;&nbsp;INT2NUM()&nbsp;&nbsp;任意の整数からVALUEへ<br />
<br />
INT2NUM()は整数がFIXNUMの範囲に収まらない場合，Bignumに変換<br />
してくれます(が，少し遅い)．<br />
<br />
1.5&nbsp;Rubyのデータを操作する<br />
<br />
先程も述べた通り，Rubyの構造体をアクセスする時に内容の更新を<br />
行うことは勧められません．で，Rubyのデータを操作する時には<br />
Rubyが用意している関数を用いてください．<br />
<br />
ここではもっとも使われるであろう文字列と配列の生成/操作を行<br />
い関数をあげます(全部ではないです)．<br />
<br />
&nbsp;文字列に対する関数<br />
<br />
&nbsp;&nbsp;rb_str_new(const&nbsp;char&nbsp;*ptr,&nbsp;long&nbsp;len)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;新しいRubyの文字列を生成する．<br />
<br />
&nbsp;&nbsp;rb_str_new2(const&nbsp;char&nbsp;*ptr)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Cの文字列からRubyの文字列を生成する．この関数の機能は<br />
&nbsp;&nbsp;&nbsp;&nbsp;rb_str_new(ptr,&nbsp;strlen(ptr))と同等である．<br />
<br />
&nbsp;&nbsp;rb_tainted_str_new(const&nbsp;char&nbsp;*ptr,&nbsp;long&nbsp;len)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;汚染マークが付加された新しいRubyの文字列を生成する．外部<br />
&nbsp;&nbsp;&nbsp;&nbsp;からのデータに基づく文字列には汚染マークが付加されるべき<br />
&nbsp;&nbsp;&nbsp;&nbsp;である．<br />
<br />
&nbsp;&nbsp;rb_tainted_str_new2(const&nbsp;char&nbsp;*ptr)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Cの文字列から汚染マークが付加されたRubyの文字列を生成する．<br />
<br />
&nbsp;&nbsp;rb_str_cat(VALUE&nbsp;str,&nbsp;const&nbsp;char&nbsp;*ptr,&nbsp;long&nbsp;len)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Rubyの文字列strにlenバイトの文字列ptrを追加する．<br />
<br />
&nbsp;配列に対する関数<br />
<br />
&nbsp;&nbsp;rb_ary_new()<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;要素が0の配列を生成する．<br />
<br />
&nbsp;&nbsp;rb_ary_new2(long&nbsp;len)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;要素が0の配列を生成する．len要素分の領域をあらかじめ割り<br />
&nbsp;&nbsp;&nbsp;&nbsp;当てておく．<br />
<br />
&nbsp;&nbsp;rb_ary_new3(long&nbsp;n,&nbsp;...)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;引数で指定したn要素を含む配列を生成する．<br />
<br />
&nbsp;&nbsp;rb_ary_new4(long&nbsp;n,&nbsp;VALUE&nbsp;*elts)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;配列で与えたn要素の配列を生成する．<br />
<br />
&nbsp;&nbsp;rb_ary_push(VALUE&nbsp;ary,&nbsp;VALUE&nbsp;val)<br />
&nbsp;&nbsp;rb_ary_pop(VALUE&nbsp;ary)<br />
&nbsp;&nbsp;rb_ary_shift(VALUE&nbsp;ary)<br />
&nbsp;&nbsp;rb_ary_unshift(VALUE&nbsp;ary,&nbsp;VALUE&nbsp;val)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;Arrayの同名のメソッドと同じ働きをする関数．第1引数は必ず<br />
&nbsp;&nbsp;&nbsp;&nbsp;配列でなければならない．<br />
<br />
2．Rubyの機能を使う<br />
<br />
原理的にRubyで書けることはCでも書けます．RubyそのものがCで記<br />
述されているんですから，当然といえば当然なんですけど．ここで<br />
はRubyの拡張に使うことが多いだろうと予測される機能を中心に紹<br />
介します．<br />
<br />
2.1&nbsp;Rubyに機能を追加する<br />
<br />
Rubyで提供されている関数を使えばRubyインタプリタに新しい機能<br />
を追加することができます．Rubyでは以下の機能を追加する関数が<br />
提供されています．<br />
<br />
&nbsp;*&nbsp;クラス，モジュール<br />
&nbsp;*&nbsp;メソッド，特異メソッドなど<br />
&nbsp;*&nbsp;定数<br />
<br />
では順に紹介します．<br />
<br />
2.1.1&nbsp;クラス/モジュール定義<br />
<br />
クラスやモジュールを定義するためには，以下の関数を使います．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_define_class(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;super)<br />
&nbsp;&nbsp;VALUE&nbsp;rb_define_module(const&nbsp;char&nbsp;*name)<br />
<br />
これらの関数は新しく定義されたクラスやモジュールを返します．<br />
メソッドや定数の定義にこれらの値が必要なので，ほとんどの場合<br />
は戻り値を変数に格納しておく必要があるでしょう．<br />
<br />
クラスやモジュールを他のクラスの内部にネストして定義する時に<br />
は以下の関数を使います．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_define_class_under(VALUE&nbsp;outer,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;super)<br />
&nbsp;&nbsp;VALUE&nbsp;rb_define_module_under(VALUE&nbsp;outer,&nbsp;const&nbsp;char&nbsp;*name)<br />
<br />
2.1.2&nbsp;メソッド/特異メソッド定義<br />
<br />
メソッドや特異メソッドを定義するには以下の関数を使います．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_method(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_singleton_method(VALUE&nbsp;object,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
<br />
念のため説明すると「特異メソッド」とは，その特定のオブジェク<br />
トに対してだけ有効なメソッドです．RubyではよくSmalltalkにお<br />
けるクラスメソッドとして，クラスに対する特異メソッドが使われ<br />
ます．<br />
<br />
これらの関数の&nbsp;argcという引数はCの関数へ渡される引数の数(と<br />
形式)を決めます．argcが0以上の時は関数に引き渡す引数の数を意<br />
味します．16個以上の引数は使えません(が，要りませんよね，そ<br />
んなに)．実際の関数には先頭の引数としてselfが与えられますの<br />
で，指定した数より1多い引数を持つことになります．<br />
<br />
argcが負の時は引数の数ではなく，形式を指定したことになります．<br />
argcが-1の時は引数を配列に入れて渡されます．argcが-2の時は引<br />
数はRubyの配列として渡されます．<br />
<br />
メソッドを定義する関数はもう二つあります．ひとつはprivateメ<br />
ソッドを定義する関数で，引数はrb_define_method()と同じです．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_private_method(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
privateメソッドとは関数形式でしか呼び出すことの出来ないメソッ<br />
ドです．<br />
<br />
もうひとつはモジュール関数を定義するものです．モジュール関数<br />
とはモジュールの特異メソッドであり，同時にprivateメソッドで<br />
もあるものです．例をあげるとMathモジュールのsqrt()などがあげ<br />
られます．このメソッドは<br />
<br />
&nbsp;&nbsp;Math.sqrt(4)<br />
<br />
という形式でも<br />
<br />
&nbsp;&nbsp;include&nbsp;Math<br />
&nbsp;&nbsp;sqrt(4)<br />
<br />
という形式でも使えます．モジュール関数を定義する関数は以下の<br />
通りです．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_module_function(VALUE&nbsp;module,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
関数的メソッド(Kernelモジュールのprivate&nbsp;method)を定義するた<br />
めの関数は以下の通りです．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_global_function(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
<br />
メソッドの別名を定義するための関数は以下の通りです。<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_alias(VALUE&nbsp;module,&nbsp;const&nbsp;char*&nbsp;new,&nbsp;const&nbsp;char*&nbsp;old);<br />
<br />
クラスメソッドallocateを定義したり削除したりするための関数は<br />
以下の通りです。<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_alloc_func(VALUE&nbsp;klass,&nbsp;VALUE&nbsp;(*func)(VALUE&nbsp;klass));<br />
&nbsp;&nbsp;void&nbsp;rb_undef_alloc_func(VALUE&nbsp;klass);<br />
<br />
funcはクラスを引数として受け取って、新しく割り当てられたイン<br />
スタンスを返さなくてはなりません。このインスタンスは、外部リ<br />
ソースなどを含まない、できるだけ「空」のままにしておいたほう<br />
がよいでしょう。<br />
<br />
2.1.3&nbsp;定数定義<br />
<br />
拡張ライブラリが必要な定数はあらかじめ定義しておいた方が良い<br />
でしょう．定数を定義する関数は二つあります．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_const(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;val)<br />
&nbsp;&nbsp;void&nbsp;rb_define_global_const(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;val)<br />
<br />
前者は特定のクラス/モジュールに属する定数を定義するもの，後<br />
者はグローバルな定数を定義するものです．<br />
<br />
2.2&nbsp;Rubyの機能をCから呼び出す<br />
<br />
既に『1.5&nbsp;Rubyのデータを操作する』で一部紹介したような関数を<br />
使えば，Rubyの機能を実現している関数を直接呼び出すことが出来<br />
ます．<br />
<br />
#&nbsp;このような関数の一覧表はいまのところありません．ソースを見<br />
#&nbsp;るしかないですね．<br />
<br />
それ以外にもRubyの機能を呼び出す方法はいくつかあります．<br />
<br />
2.2.1&nbsp;Rubyのプログラムをevalする<br />
<br />
CからRubyの機能を呼び出すもっとも簡単な方法として，文字列で<br />
与えられたRubyのプログラムを評価する以下の関数があります．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_eval_string(const&nbsp;char&nbsp;*str)<br />
<br />
この評価は現在の環境で行われます．つまり，現在のローカル変数<br />
などを受け継ぎます．<br />
<br />
2.2.2&nbsp;IDまたはシンボル<br />
<br />
Cから文字列を経由せずにRubyのメソッドを呼び出すこともできま<br />
す．その前に，Rubyインタプリタ内でメソッドや変数名を指定する<br />
時に使われているIDについて説明しておきましょう．<br />
<br />
IDとは変数名，メソッド名を表す整数です．Rubyの中では<br />
<br />
&nbsp;:識別子<br />
<br />
でアクセスできます．Cからこの整数を得るためには関数<br />
<br />
&nbsp;&nbsp;rb_intern(const&nbsp;char&nbsp;*name)<br />
<br />
を使います．Rubyから引数として与えられたシンボル(または文字<br />
列)をIDに変換するには以下の関数を使います．<br />
<br />
&nbsp;&nbsp;rb_to_id(VALUE&nbsp;symbol)<br />
<br />
2.2.3&nbsp;CからRubyのメソッドを呼び出す<br />
<br />
Cから文字列を経由せずにRubyのメソッドを呼び出すためには以下<br />
の関数を使います．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_funcall(VALUE&nbsp;recv,&nbsp;ID&nbsp;mid,&nbsp;int&nbsp;argc,&nbsp;...)<br />
<br />
この関数はオブジェクトrecvのmidで指定されるメソッドを呼び出<br />
します．その他に引数の指定の仕方が違う以下の関数もあります．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_funcall2(VALUE&nbsp;recv,&nbsp;ID&nbsp;mid,&nbsp;int&nbsp;argc,&nbsp;VALUE&nbsp;*argv)<br />
&nbsp;&nbsp;VALUE&nbsp;rb_apply(VALUE&nbsp;recv,&nbsp;ID&nbsp;mid,&nbsp;VALUE&nbsp;args)<br />
<br />
applyには引数としてRubyの配列を与えます．<br />
<br />
2.2.4&nbsp;変数/定数を参照/更新する<br />
<br />
Cから関数を使って参照・更新できるのは，定数，インスタンス変<br />
数です．大域変数は一部のものはCの大域変数としてアクセスでき<br />
ます．ローカル変数を参照する方法は公開していません．<br />
<br />
オブジェクトのインスタンス変数を参照・更新する関数は以下の通<br />
りです．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_ivar_get(VALUE&nbsp;obj,&nbsp;ID&nbsp;id)<br />
&nbsp;&nbsp;VALUE&nbsp;rb_ivar_set(VALUE&nbsp;obj,&nbsp;ID&nbsp;id,&nbsp;VALUE&nbsp;val)<br />
<br />
idはrb_intern()で得られるものを使ってください．<br />
<br />
定数を参照するには以下の関数を使ってください．<br />
<br />
&nbsp;&nbsp;VALUE&nbsp;rb_const_get(VALUE&nbsp;obj,&nbsp;ID&nbsp;id)<br />
<br />
定数を新しく定義するためには『2.1.3&nbsp;定数定義』で紹介さ<br />
れている関数を使ってください．<br />
<br />
3．RubyとCとの情報共有<br />
<br />
C言語とRubyの間で情報を共有する方法について解説します．<br />
<br />
3.1&nbsp;Cから参照できるRubyの定数<br />
<br />
以下のRubyの定数はCのレベルから参照できます．<br />
<br />
&nbsp;&nbsp;Qtrue<br />
&nbsp;&nbsp;Qfalse<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;真偽値．QfalseはC言語でも偽とみなされます(つまり0)．<br />
<br />
&nbsp;&nbsp;Qnil<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;C言語から見た「nil」．<br />
<br />
3.2&nbsp;CとRubyで共有される大域変数<br />
<br />
CとRubyで大域変数を使って情報を共有できます．共有できる大域<br />
変数にはいくつかの種類があります．そのなかでもっとも良く使わ<br />
れると思われるのはrb_define_variable()です．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var)<br />
<br />
この関数はRubyとCとで共有する大域変数を定義します．変数名が<br />
`$'で始まらない時には自動的に追加されます．この変数の値を変<br />
更すると自動的にRubyの対応する変数の値も変わります．<br />
<br />
またRuby側からは更新できない変数もあります．このread&nbsp;onlyの<br />
変数は以下の関数で定義します．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_readonly_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var)<br />
<br />
これら変数の他にhookをつけた大域変数を定義できます．hook付き<br />
の大域変数は以下の関数を用いて定義します．hook付き大域変数の<br />
値の参照や設定はhookで行う必要があります．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_hooked_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*getter)(),&nbsp;void&nbsp;(*setter)())<br />
<br />
この関数はCの関数によってhookのつけられた大域変数を定義しま<br />
す．変数が参照された時には関数getterが，変数に値がセットされ<br />
た時には関数setterが呼ばれる．hookを指定しない場合はgetterや<br />
setterに0を指定します．<br />
<br />
#&nbsp;getterもsetterも0ならばrb_define_variable()と同じになる．<br />
<br />
それから，Cの関数によって実現されるRubyの大域変数を定義する<br />
関数があります．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_define_virtual_variable(const&nbsp;char&nbsp;*name,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*getter)(),&nbsp;void&nbsp;(*setter)())<br />
<br />
この関数によって定義されたRubyの大域変数が参照された時には<br />
getterが，変数に値がセットされた時にはsetterが呼ばれます．<br />
<br />
getterとsetterの仕様は以下の通りです．<br />
<br />
&nbsp;&nbsp;(*getter)(ID&nbsp;id,&nbsp;void&nbsp;*data,&nbsp;struct&nbsp;global_entry*&nbsp;entry);<br />
&nbsp;&nbsp;(*setter)(VALUE&nbsp;val,&nbsp;ID&nbsp;id,&nbsp;void&nbsp;*data,&nbsp;struct&nbsp;global_entry*&nbsp;entry);<br />
<br />
3.3&nbsp;CのデータをRubyオブジェクトにする<br />
<br />
Cの世界で定義されたデータ(構造体)をRubyのオブジェクトとして<br />
取り扱いたい場合がありえます．このような場合には，Dataという<br />
RubyオブジェクトにCの構造体(へのポインタ)をくるむことでRuby<br />
オブジェクトとして取り扱えるようになります．<br />
<br />
Dataオブジェクトを生成して構造体をRubyオブジェクトにカプセル<br />
化するためには，以下のマクロを使います．<br />
<br />
&nbsp;&nbsp;Data_Wrap_Struct(klass,&nbsp;mark,&nbsp;free,&nbsp;ptr)<br />
<br />
このマクロの戻り値は生成されたDataオブジェクトです．<br />
<br />
klassはこのDataオブジェクトのクラスです．ptrはカプセル化する<br />
Cの構造体へのポインタです．markはこの構造体がRubyのオブジェ<br />
クトへの参照がある時に使う関数です．そのような参照を含まない<br />
時には0を指定します．<br />
<br />
#&nbsp;そのような参照は勧められません．<br />
<br />
freeはこの構造体がもう不要になった時に呼ばれる関数です．この<br />
関数がガーベージコレクタから呼ばれます．これが-1の場合は，単<br />
純に開放されます．<br />
<br />
Cの構造体の割当とDataオブジェクトの生成を同時に行うマクロと<br />
して以下のものが提供されています．<br />
<br />
&nbsp;&nbsp;Data_Make_Struct(klass,&nbsp;type,&nbsp;mark,&nbsp;free,&nbsp;sval)<br />
<br />
このマクロの戻り値は生成されたDataオブジェクトです．<br />
<br />
klass,&nbsp;mark,&nbsp;freeはData_Wrap_Structと同じ働きをします．type<br />
は割り当てるC構造体の型です．割り当てられた構造体は変数sval<br />
に代入されます．この変数の型は&nbsp;(type*)&nbsp;である必要があります．<br />
<br />
Dataオブジェクトからポインタを取り出すのは以下のマクロを用い<br />
ます．<br />
<br />
&nbsp;&nbsp;Data_Get_Struct(obj,&nbsp;type,&nbsp;sval)<br />
<br />
Cの構造体へのポインタは変数svalに代入されます．<br />
<br />
これらのDataの使い方はちょっと分かりにくいので，後で説明する<br />
例題を参照してください．<br />
<br />
4．例題&nbsp;-&nbsp;dbmパッケージを作る<br />
<br />
ここまでの説明でとりあえず拡張ライブラリは作れるはずです．<br />
Rubyのextディレクトリにすでに含まれているdbmライブラリを例に<br />
して段階的に説明します．<br />
<br />
(1)&nbsp;ディレクトリを作る<br />
<br />
&nbsp;&nbsp;%&nbsp;mkdir&nbsp;ext/dbm<br />
<br />
Ruby&nbsp;1.1からは任意のディレクトリでダイナミックライブラリを作<br />
ることができるようになりました．Rubyに静的にリンクする場合に<br />
はRubyを展開したディレクトリの下，extディレクトリの中に拡張<br />
ライブラリ用のディレクトリを作る必要があります．名前は適当に<br />
選んで構いません．<br />
<br />
(2)&nbsp;設計する<br />
<br />
まあ，当然なんですけど，どういう機能を実現するかどうかまず設<br />
計する必要があります．どんなクラスをつくるか，そのクラスには<br />
どんなメソッドがあるか，クラスが提供する定数などについて設計<br />
します．<br />
<br />
(3)&nbsp;Cコードを書く<br />
<br />
拡張ライブラリ本体となるC言語のソースを書きます．C言語のソー<br />
スがひとつの時には「ライブラリ名.c」を選ぶと良いでしょう．C<br />
言語のソースが複数の場合には逆に「ライブラリ名.c」というファ<br />
イル名は避ける必要があります．オブジェクトファイルとモジュー<br />
ル生成時に中間的に生成される「ライブラリ名.o」というファイル<br />
とが衝突するからです．<br />
<br />
Rubyは拡張ライブラリをロードする時に「Init_ライブラリ名」と<br />
いう関数を自動的に実行します．dbmライブラリの場合「Init_dbm」<br />
です．この関数の中でクラス，モジュール，メソッド，定数などの<br />
定義を行います．dbm.cから一部引用します．<br />
<br />
--<br />
Init_dbm()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMクラスを定義する&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;cDBM&nbsp;=&nbsp;rb_define_class(&quot;DBM&quot;,&nbsp;rb_cObject);<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMはEnumerateモジュールをインクルードする&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;rb_include_module(cDBM,&nbsp;rb_mEnumerable);<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMクラスのクラスメソッドopen():&nbsp;引数はCの配列で受ける&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;rb_define_singleton_method(cDBM,&nbsp;&quot;open&quot;,&nbsp;fdbm_s_open,&nbsp;-1);<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMクラスのメソッドclose():&nbsp;引数はなし&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;rb_define_method(cDBM,&nbsp;&quot;close&quot;,&nbsp;fdbm_close,&nbsp;0);<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMクラスのメソッド[]:&nbsp;引数は1個&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;rb_define_method(cDBM,&nbsp;&quot;[]&quot;,&nbsp;fdbm_fetch,&nbsp;1);<br />
&nbsp;&nbsp;&nbsp;:<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DBMデータを格納するインスタンス変数名のためのID&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;id_dbm&nbsp;=&nbsp;rb_intern(&quot;dbm&quot;);<br />
}<br />
--<br />
<br />
DBMライブラリはdbmのデータと対応するオブジェクトになるはずで<br />
すから，Cの世界のdbmをRubyの世界に取り込む必要があります．<br />
<br />
<br />
dbm.cではData_Make_Structを以下のように使っています．<br />
<br />
--<br />
struct&nbsp;dbmdata&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;di_size;<br />
&nbsp;&nbsp;&nbsp;&nbsp;DBM&nbsp;*di_dbm;<br />
};<br />
<br />
<br />
obj&nbsp;=&nbsp;Data_Make_Struct(klass,&nbsp;struct&nbsp;dbmdata,&nbsp;0,&nbsp;free_dbm,&nbsp;dbmp);<br />
--<br />
<br />
ここではdbmstruct構造体へのポインタをDataにカプセル化してい<br />
ます．DBM*を直接カプセル化しないのはclose()した時の処理を考<br />
えてのことです．<br />
<br />
Dataオブジェクトからdbmstruct構造体のポインタを取り出すため<br />
に以下のマクロを使っています．<br />
<br />
--<br />
#define&nbsp;GetDBM(obj,&nbsp;dbmp)&nbsp;{\<br />
&nbsp;&nbsp;&nbsp;&nbsp;Data_Get_Struct(obj,&nbsp;struct&nbsp;dbmdata,&nbsp;dbmp);\<br />
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dbmp-&gt;di_dbm&nbsp;==&nbsp;0)&nbsp;closed_dbm();\<br />
}<br />
--<br />
<br />
ちょっと複雑なマクロですが，要するにdbmdata構造体のポインタ<br />
の取り出しと，closeされているかどうかのチェックをまとめてい<br />
るだけです．<br />
<br />
DBMクラスにはたくさんメソッドがありますが，分類すると3種類の<br />
引数の受け方があります．ひとつは引数の数が固定のもので，例と<br />
してはdeleteメソッドがあります．deleteメソッドを実装している<br />
fdbm_delete()はこのようになっています．<br />
<br />
--<br />
static&nbsp;VALUE<br />
fdbm_delete(obj,&nbsp;keystr)<br />
&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;obj,&nbsp;keystr;<br />
{<br />
&nbsp;&nbsp;:<br />
}<br />
--<br />
<br />
引数の数が固定のタイプは第1引数がself，第2引数以降がメソッド<br />
の引数となります．<br />
<br />
引数の数が不定のものはCの配列で受けるものとRubyの配列で受け<br />
るものとがあります．dbmライブラリの中で，Cの配列で受けるもの<br />
はDBMのクラスメソッドであるopen()です．これを実装している関<br />
数fdbm_s_open()はこうなっています．<br />
<br />
--<br />
static&nbsp;VALUE<br />
fdbm_s_open(argc,&nbsp;argv,&nbsp;klass)<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;argc;<br />
&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;*argv;<br />
&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;klass;<br />
{<br />
&nbsp;&nbsp;:<br />
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rb_scan_args(argc,&nbsp;argv,&nbsp;&quot;11&quot;,&nbsp;&amp;file,&nbsp;&amp;vmode)&nbsp;==&nbsp;1)&nbsp;{<br />
&nbsp;&nbsp;mode&nbsp;=&nbsp;0666;&nbsp;&nbsp;/*&nbsp;default&nbsp;value&nbsp;*/<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;:<br />
}<br />
--<br />
<br />
このタイプの関数は第1引数が与えられた引数の数，第2引数が与え<br />
られた引数の入っている配列になります．selfは第3引数として与<br />
えられます．<br />
<br />
この配列で与えられた引数を解析するための関数がopen()でも使わ<br />
れているrb_scan_args()です．第3引数に指定したフォーマットに<br />
従い，第4変数以降に指定した変数に値を代入してくれます．この<br />
フォーマットは，第1文字目が省略できない引数の数，第2文字目が<br />
省略できる引数の数，第3文字目が対応する相手が無いあまりの引<br />
数があるかどうかを示す&quot;*&quot;です．2文字目と3文字目は省略できま<br />
す．dbm.cの例では，フォーマットは&quot;11&quot;ですから，引数は最低1つ<br />
で，2つまで許されるという意味になります．省略されている時の<br />
変数の値はnil(C言語のレベルではQnil)になります．<br />
<br />
Rubyの配列で引数を受け取るものはindexesがあります．実装はこ<br />
うです．<br />
<br />
--<br />
static&nbsp;VALUE<br />
fdbm_indexes(obj,&nbsp;args)<br />
&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;obj,&nbsp;args;<br />
{<br />
&nbsp;&nbsp;:<br />
}<br />
--<br />
<br />
第1引数はself，第2引数はRubyの配列です．<br />
<br />
**&nbsp;注意事項<br />
<br />
Rubyと共有はしないがRubyのオブジェクトを格納する可能性のある<br />
Cの大域変数は以下の関数を使ってRubyインタプリタに変数の存在<br />
を教えてあげてください．でないとGCでトラブルを起こします．<br />
<br />
&nbsp;&nbsp;void&nbsp;rb_global_variable(VALUE&nbsp;*var)<br />
<br />
(4)&nbsp;extconf.rbを用意する<br />
<br />
Makefileを作る場合の雛型になるextconf.rbというファイルを作り<br />
ます．extconf.rbはライブラリのコンパイルに必要な条件のチェッ<br />
クなどを行うことが目的です．まず，<br />
<br />
&nbsp;&nbsp;require&nbsp;'mkmf'<br />
<br />
をextconf.rbの先頭に置きます．extconf.rbの中では以下のRuby関<br />
数を使うことが出来ます．<br />
<br />
&nbsp;&nbsp;have_library(lib,&nbsp;func):&nbsp;ライブラリの存在チェック<br />
&nbsp;&nbsp;have_func(func,&nbsp;header):&nbsp;関数の存在チェック<br />
&nbsp;&nbsp;have_header(header):&nbsp;ヘッダファイルの存在チェック<br />
&nbsp;&nbsp;create_makefile(target):&nbsp;Makefileの生成<br />
<br />
以下の変数を使うことができます．<br />
<br />
&nbsp;&nbsp;$CFLAGS:&nbsp;コンパイル時に追加的に指定するフラグ(-Oなど)<br />
&nbsp;&nbsp;$CPPFLAGS:&nbsp;プリプロセッサに追加的に指定するフラグ(-Iや-Dなど)<br />
&nbsp;&nbsp;$LDFLAGS:&nbsp;リンク時に追加的に指定するフラグ(-Lなど)<br />
&nbsp;&nbsp;$objs:&nbsp;リンクされるオブジェクトファイル名のリスト<br />
<br />
オブジェクトファイルのリストは、通常はソースファイルを検索し<br />
て自動的に生成されますが、makeの途中でソースを生成するような<br />
場合は明示的に指定する必要があります。<br />
<br />
ライブラリをコンパイルする条件が揃わず，そのライブラリをコン<br />
パイルしない時にはcreate_makefileを呼ばなければMakefileは生<br />
成されず，コンパイルも行われません．<br />
<br />
(5)&nbsp;dependを用意する<br />
<br />
もし，ディレクトリにdependというファイルが存在すれば，<br />
Makefileが依存関係をチェックしてくれます．<br />
<br />
&nbsp;&nbsp;%&nbsp;gcc&nbsp;-MM&nbsp;*.c&nbsp;&gt;&nbsp;depend<br />
<br />
などで作ることが出来ます．あって損は無いでしょう．<br />
<br />
(6)&nbsp;Makefileを生成する<br />
<br />
Makefileを実際に生成するためには<br />
<br />
&nbsp;&nbsp;ruby&nbsp;extconf.rb<br />
<br />
とします．extconf.rbに&nbsp;require&nbsp;'mkmf'&nbsp;の行がない場合にはエラー<br />
になりますので，引数を追加して<br />
<br />
&nbsp;&nbsp;ruby&nbsp;-r&nbsp;mkmf&nbsp;extconf.rb<br />
<br />
としてください．<br />
<br />
ディレクトリをext以下に用意した場合にはRuby全体のmakeの時に<br />
自動的にMakefileが生成されますので，このステップは不要です．<br />
<br />
(7)&nbsp;makeする<br />
<br />
動的リンクライブラリを生成する場合にはその場でmakeしてくださ<br />
い．必要であれば&nbsp;make&nbsp;install&nbsp;でインストールされます．<br />
<br />
ext以下にディレクトリを用意した場合は，Rubyのディレクトリで<br />
makeを実行するとMakefileを生成からmake，必要によってはそのモ<br />
ジュールのRubyへのリンクまで自動的に実行してくれます．<br />
extconf.rbを書き換えるなどしてMakefileの再生成が必要な時はま<br />
たRubyディレクトリでmakeしてください．<br />
<br />
拡張ライブラリはmake&nbsp;installでRubyライブラリのディレクトリの<br />
下にコピーされます．もし拡張ライブラリと協調して使うRubyで記<br />
述されたプログラムがあり，Rubyライブラリに置きたい場合には，<br />
拡張ライブラリ用のディレクトリの下に&nbsp;lib&nbsp;というディレクトリ<br />
を作り，そこに&nbsp;拡張子&nbsp;.rb&nbsp;のファイルを置いておけば同時にイン<br />
ストールされます．<br />
<br />
(8)&nbsp;デバッグ<br />
<br />
まあ，デバッグしないと動かないでしょうね．ext/Setupにディレ<br />
クトリ名を書くと静的にリンクするのでデバッガが使えるようにな<br />
ります．その分コンパイルが遅くなりますけど．<br />
<br />
(9)&nbsp;できあがり<br />
<br />
後はこっそり使うなり，広く公開するなり，売るなり，ご自由にお<br />
使いください．Rubyの作者は拡張ライブラリに関して一切の権利を<br />
主張しません．<br />
<br />
Appendix&nbsp;A.&nbsp;Rubyのソースコードの分類<br />
<br />
Rubyのソースはいくつかに分類することが出来ます．このうちクラ<br />
スライブラリの部分は基本的に拡張ライブラリと同じ作り方になっ<br />
ています．これらのソースは今までの説明でほとんど理解できると<br />
思います．<br />
<br />
Ruby言語のコア<br />
<br />
&nbsp;&nbsp;class.c<br />
&nbsp;&nbsp;error.c<br />
&nbsp;&nbsp;eval.c<br />
&nbsp;&nbsp;gc.c<br />
&nbsp;&nbsp;object.c<br />
&nbsp;&nbsp;parse.y<br />
&nbsp;&nbsp;variable.c<br />
<br />
ユーティリティ関数<br />
<br />
&nbsp;&nbsp;dln.c<br />
&nbsp;&nbsp;regex.c<br />
&nbsp;&nbsp;st.c<br />
&nbsp;&nbsp;util.c<br />
<br />
Rubyコマンドの実装<br />
<br />
&nbsp;&nbsp;dmyext.c<br />
&nbsp;&nbsp;inits.c<br />
&nbsp;&nbsp;main.c<br />
&nbsp;&nbsp;ruby.c<br />
&nbsp;&nbsp;version.c<br />
<br />
クラスライブラリ<br />
<br />
&nbsp;&nbsp;array.c<br />
&nbsp;&nbsp;bignum.c<br />
&nbsp;&nbsp;compar.c<br />
&nbsp;&nbsp;dir.c<br />
&nbsp;&nbsp;enum.c<br />
&nbsp;&nbsp;file.c<br />
&nbsp;&nbsp;hash.c<br />
&nbsp;&nbsp;io.c<br />
&nbsp;&nbsp;marshal.c<br />
&nbsp;&nbsp;math.c<br />
&nbsp;&nbsp;numeric.c<br />
&nbsp;&nbsp;pack.c<br />
&nbsp;&nbsp;prec.c<br />
&nbsp;&nbsp;process.c<br />
&nbsp;&nbsp;random.c<br />
&nbsp;&nbsp;range.c<br />
&nbsp;&nbsp;re.c<br />
&nbsp;&nbsp;signal.c<br />
&nbsp;&nbsp;sprintf.c<br />
&nbsp;&nbsp;string.c<br />
&nbsp;&nbsp;struct.c<br />
&nbsp;&nbsp;time.c<br />
<br />
Appendix&nbsp;B.&nbsp;拡張用関数リファレンス<br />
<br />
C言語からRubyの機能を利用するAPIは以下の通りである．<br />
<br />
**&nbsp;型<br />
<br />
VALUE<br />
<br />
&nbsp;&nbsp;Rubyオブジェクトを表現する型．必要に応じてキャストして用いる．<br />
&nbsp;&nbsp;組み込み型を表現するCの型はruby.hに記述してあるRで始まる構造<br />
&nbsp;&nbsp;体である．VALUE型をこれらにキャストするためにRで始まる構造体<br />
&nbsp;&nbsp;名を全て大文字にした名前のマクロが用意されている．<br />
<br />
**&nbsp;変数・定数<br />
<br />
Qnil<br />
<br />
&nbsp;&nbsp;定数:&nbsp;nilオブジェクト<br />
<br />
Qtrue<br />
<br />
&nbsp;&nbsp;定数:&nbsp;trueオブジェクト(真のデフォルト値)<br />
<br />
Qfalse<br />
<br />
&nbsp;&nbsp;定数:&nbsp;falseオブジェクト<br />
<br />
**&nbsp;Cデータのカプセル化<br />
<br />
Data_Wrap_Struct(VALUE&nbsp;klass,&nbsp;void&nbsp;(*mark)(),&nbsp;void&nbsp;(*free)(),&nbsp;void&nbsp;*sval)<br />
<br />
&nbsp;&nbsp;Cの任意のポインタをカプセル化したRubyオブジェクトを返す．こ<br />
&nbsp;&nbsp;のポインタがRubyからアクセスされなくなった時，freeで指定した<br />
&nbsp;&nbsp;関数が呼ばれる．また，このポインタの指すデータが他のRubyオブ<br />
&nbsp;&nbsp;ジェクトを指している場合，markに指定する関数でマークする必要<br />
&nbsp;&nbsp;がある．<br />
<br />
Data_Make_Struct(klass,&nbsp;type,&nbsp;mark,&nbsp;free,&nbsp;sval)<br />
<br />
&nbsp;&nbsp;type型のメモリをmallocし，変数svalに代入した後，それをカプセ<br />
&nbsp;&nbsp;ル化したデータを返すマクロ．<br />
<br />
Data_Get_Struct(data,&nbsp;type,&nbsp;sval)<br />
<br />
&nbsp;&nbsp;dataからtype型のポインタを取り出し変数svalに代入するマクロ．<br />
<br />
**&nbsp;型チェック<br />
<br />
TYPE(value)<br />
FIXNUM_P(value)<br />
NIL_P(value)<br />
void&nbsp;Check_Type(VALUE&nbsp;value,&nbsp;int&nbsp;type)<br />
void&nbsp;Check_SafeStr(VALUE&nbsp;value)<br />
<br />
**&nbsp;型変換<br />
<br />
FIX2INT(value)<br />
INT2FIX(i)<br />
NUM2INT(value)<br />
INT2NUM(i)<br />
NUM2DBL(value)<br />
rb_float_new(f)<br />
StringValue(value)<br />
StringValuePtr(value)<br />
StringValueCStr(value)<br />
rb_str_new2(s)<br />
<br />
**&nbsp;クラス/モジュール定義<br />
<br />
VALUE&nbsp;rb_define_class(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;super)<br />
<br />
&nbsp;&nbsp;superのサブクラスとして新しいRubyクラスを定義する．<br />
<br />
VALUE&nbsp;rb_define_class_under(VALUE&nbsp;module,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;super)<br />
<br />
&nbsp;&nbsp;superのサブクラスとして新しいRubyクラスを定義し，moduleの<br />
&nbsp;&nbsp;定数として定義する．<br />
<br />
VALUE&nbsp;rb_define_module(const&nbsp;char&nbsp;*name)<br />
<br />
&nbsp;&nbsp;新しいRubyモジュールを定義する．<br />
<br />
VALUE&nbsp;rb_define_module_under(VALUE&nbsp;module,&nbsp;const&nbsp;char&nbsp;*name)<br />
<br />
&nbsp;&nbsp;新しいRubyモジュールを定義し，moduleの定数として定義する．<br />
<br />
void&nbsp;rb_include_module(VALUE&nbsp;klass,&nbsp;VALUE&nbsp;module)<br />
<br />
&nbsp;&nbsp;モジュールをインクルードする．classがすでにmoduleをインク<br />
&nbsp;&nbsp;ルードしている時には何もしない(多重インクルードの禁止)．<br />
<br />
void&nbsp;rb_extend_object(VALUE&nbsp;object,&nbsp;VALUE&nbsp;module)<br />
<br />
&nbsp;&nbsp;オブジェクトをモジュール(で定義されているメソッド)で拡張する．<br />
<br />
**&nbsp;大域変数定義<br />
<br />
void&nbsp;rb_define_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var)<br />
<br />
&nbsp;&nbsp;RubyとCとで共有するグローバル変数を定義する．変数名が`$'で<br />
&nbsp;&nbsp;始まらない時には自動的に追加される．nameとしてRubyの識別子<br />
&nbsp;&nbsp;として許されない文字(例えば`&nbsp;')を含む場合にはRubyプログラ<br />
&nbsp;&nbsp;ムからは見えなくなる．<br />
<br />
void&nbsp;rb_define_readonly_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var)<br />
<br />
&nbsp;&nbsp;RubyとCとで共有するread&nbsp;onlyのグローバル変数を定義する．<br />
&nbsp;&nbsp;read&nbsp;onlyであること以外はrb_define_variable()と同じ．<br />
<br />
void&nbsp;rb_define_virtual_variable(const&nbsp;char&nbsp;*name,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*getter)(),&nbsp;void&nbsp;(*setter)())<br />
<br />
&nbsp;&nbsp;関数によって実現されるRuby変数を定義する．変数が参照された<br />
&nbsp;&nbsp;時にはgetterが，変数に値がセットされた時にはsetterが呼ばれ<br />
&nbsp;&nbsp;る．<br />
<br />
void&nbsp;rb_define_hooked_variable(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;*var,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;(*getter)(),&nbsp;void&nbsp;(*setter)())<br />
<br />
&nbsp;&nbsp;関数によってhookのつけられたグローバル変数を定義する．変数<br />
&nbsp;&nbsp;が参照された時にはgetterが，関数に値がセットされた時には<br />
&nbsp;&nbsp;setterが呼ばれる．getterやsetterに0を指定した時にはhookを<br />
&nbsp;&nbsp;指定しないのと同じ事になる．<br />
<br />
void&nbsp;rb_global_variable(VALUE&nbsp;*var)<br />
<br />
&nbsp;&nbsp;GCのため，Rubyプログラムからはアクセスされないが,&nbsp;Rubyオブ<br />
&nbsp;&nbsp;ジェクトを含む大域変数をマークする．<br />
<br />
**&nbsp;定数<br />
<br />
void&nbsp;rb_define_const(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;val)<br />
<br />
&nbsp;&nbsp;定数を定義する．<br />
<br />
void&nbsp;rb_define_global_const(const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;val)<br />
<br />
&nbsp;&nbsp;大域定数を定義する．<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rb_define_const(rb_cObject,&nbsp;name,&nbsp;val)<br />
<br />
&nbsp;&nbsp;と同じ意味．<br />
<br />
**&nbsp;メソッド定義<br />
<br />
rb_define_method(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
&nbsp;&nbsp;メソッドを定義する．argcはselfを除く引数の数．argcが-1の時,&nbsp;<br />
&nbsp;&nbsp;関数には引数の数(selfを含まない)を第1引数,&nbsp;引数の配列を第2<br />
&nbsp;&nbsp;引数とする形式で与えられる(第3引数はself)．argcが-2の時,&nbsp;<br />
&nbsp;&nbsp;第1引数がself,&nbsp;第2引数がargs(argsは引数を含むRubyの配列)と<br />
&nbsp;&nbsp;いう形式で与えられる．<br />
&nbsp;<br />
rb_define_private_method(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
&nbsp;&nbsp;privateメソッドを定義する．引数はrb_define_method()と同じ．<br />
<br />
rb_define_singleton_method(VALUE&nbsp;klass,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;(*func)(),&nbsp;int&nbsp;argc)<br />
<br />
&nbsp;&nbsp;特異メソッドを定義する．引数はrb_define_method()と同じ．<br />
<br />
rb_scan_args(int&nbsp;argc,&nbsp;VALUE&nbsp;*argv,&nbsp;const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;argc,&nbsp;argv形式で与えられた引数を分解する．fmtは必須引数の数,&nbsp;<br />
&nbsp;&nbsp;付加引数の数,&nbsp;残りの引数があるかを指定する文字列で,&nbsp;&quot;数字<br />
&nbsp;&nbsp;数字*&quot;という形式である．&nbsp;2&nbsp;番目の数字と&quot;*&quot;はそれぞれ省略可<br />
&nbsp;&nbsp;能である．必須引数が一つもない場合は0を指定する．第3引数以<br />
&nbsp;&nbsp;降は変数へのポインタで,&nbsp;該当する要素がその変数に格納される．<br />
&nbsp;&nbsp;付加引数に対応する引数が与えられていない場合は変数にQnilが<br />
&nbsp;&nbsp;代入される．<br />
<br />
**&nbsp;Rubyメソッド呼び出し<br />
<br />
VALUE&nbsp;rb_funcall(VALUE&nbsp;recv,&nbsp;ID&nbsp;mid,&nbsp;int&nbsp;narg,&nbsp;...)<br />
<br />
&nbsp;&nbsp;メソッド呼び出し．文字列からmidを得るためにはrb_intern()を<br />
&nbsp;&nbsp;使う．<br />
<br />
VALUE&nbsp;rb_funcall2(VALUE&nbsp;recv,&nbsp;ID&nbsp;mid,&nbsp;int&nbsp;argc,&nbsp;VALUE&nbsp;*argv)<br />
<br />
&nbsp;&nbsp;メソッド呼び出し．引数をargc,&nbsp;argv形式で渡す．<br />
<br />
VALUE&nbsp;rb_eval_string(const&nbsp;char&nbsp;*str)<br />
<br />
&nbsp;&nbsp;文字列をRubyスクリプトとしてコンパイル・実行する．<br />
<br />
ID&nbsp;rb_intern(const&nbsp;char&nbsp;*name)<br />
<br />
&nbsp;&nbsp;文字列に対応するIDを返す．<br />
<br />
char&nbsp;*rb_id2name(ID&nbsp;id)<br />
<br />
&nbsp;&nbsp;IDに対応する文字列を返す(デバッグ用)．<br />
<br />
char&nbsp;*rb_class2name(VALUE&nbsp;klass)<br />
<br />
&nbsp;&nbsp;クラスの名前を返す(デバッグ用)．クラスが名前を持たない時には,&nbsp;<br />
&nbsp;&nbsp;祖先を遡って名前を持つクラスの名前を返す．<br />
<br />
int&nbsp;rb_respond_to(VALUE&nbsp;obj,&nbsp;ID&nbsp;id)<br />
<br />
&nbsp;&nbsp;objがidで示されるメソッドを持つかどうかを返す。<br />
<br />
**&nbsp;インスタンス変数<br />
<br />
VALUE&nbsp;rb_iv_get(VALUE&nbsp;obj,&nbsp;const&nbsp;char&nbsp;*name)<br />
<br />
&nbsp;&nbsp;objのインスタンス変数の値を得る．`@'で始まらないインスタン<br />
&nbsp;&nbsp;ス変数は&nbsp;Rubyプログラムからアクセスできない「隠れた」イン<br />
&nbsp;&nbsp;スタンス変数になる．定数は大文字の名前を持つクラス(または<br />
&nbsp;&nbsp;モジュール)のインスタンス変数として実装されている．<br />
<br />
VALUE&nbsp;rb_iv_set(VALUE&nbsp;obj,&nbsp;const&nbsp;char&nbsp;*name,&nbsp;VALUE&nbsp;val)<br />
<br />
&nbsp;&nbsp;objのインスタンス変数をvalにセットする．<br />
<br />
**&nbsp;制御構造<br />
<br />
VALUE&nbsp;rb_iterate(VALUE&nbsp;(*func1)(),&nbsp;VALUE&nbsp;arg1,&nbsp;VALUE&nbsp;(*func2)(),&nbsp;VALUE&nbsp;arg2)<br />
<br />
&nbsp;&nbsp;func2をブロックとして設定し,&nbsp;func1をイテレータとして呼ぶ．&nbsp;<br />
&nbsp;&nbsp;func1には&nbsp;arg1が引数として渡され,&nbsp;func2には第1引数にイテレー<br />
&nbsp;&nbsp;タから与えられた値,&nbsp;第2引数にarg2が渡される．<br />
&nbsp;<br />
VALUE&nbsp;rb_yield(VALUE&nbsp;val)<br />
<br />
&nbsp;&nbsp;valを値としてイテレータブロックを呼び出す．<br />
<br />
VALUE&nbsp;rb_rescue(VALUE&nbsp;(*func1)(),&nbsp;VALUE&nbsp;arg1,&nbsp;VALUE&nbsp;(*func2)(),&nbsp;VALUE&nbsp;arg2)<br />
<br />
&nbsp;&nbsp;関数func1をarg1を引数に呼び出す．func1の実行中に例外が発生<br />
&nbsp;&nbsp;した時には&nbsp;func2をarg2を引数として呼ぶ．戻り値は例外が発生<br />
&nbsp;&nbsp;しなかった時はfunc1の戻り値,&nbsp;例外が発生した時にはfunc2の戻<br />
&nbsp;&nbsp;り値である．<br />
<br />
VALUE&nbsp;rb_ensure(VALUE&nbsp;(*func1)(),&nbsp;VALUE&nbsp;arg1,&nbsp;void&nbsp;(*func2)(),&nbsp;VALUE&nbsp;arg2)<br />
<br />
&nbsp;&nbsp;関数func1をarg1を引数として実行し,&nbsp;実行終了後(たとえ例外が<br />
&nbsp;&nbsp;発生しても)&nbsp;func2をarg2を引数として実行する．戻り値はfunc1<br />
&nbsp;&nbsp;の戻り値である(例外が発生した時は戻らない)．<br />
<br />
**&nbsp;例外・エラー<br />
<br />
void&nbsp;rb_warning(const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;rb_verbose時に標準エラー出力に警告情報を表示する．引数は<br />
&nbsp;&nbsp;printf()と同じ．<br />
<br />
void&nbsp;rb_raise(rb_eRuntimeError,&nbsp;const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;RuntimeError例外を発生させる．引数はprintf()と同じ．<br />
<br />
void&nbsp;rb_raise(VALUE&nbsp;exception,&nbsp;const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;exceptionで指定した例外を発生させる．fmt以下の引数は<br />
&nbsp;&nbsp;printf()と同じ．<br />
<br />
void&nbsp;rb_fatal(const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;致命的例外を発生させる．通常の例外処理は行なわれず,&nbsp;インター<br />
&nbsp;&nbsp;プリタが終了する(ただしensureで指定されたコードは終了前に<br />
&nbsp;&nbsp;実行される)．<br />
<br />
void&nbsp;rb_bug(const&nbsp;char&nbsp;*fmt,&nbsp;...)<br />
<br />
&nbsp;&nbsp;インタープリタなどプログラムのバグでしか発生するはずのない<br />
&nbsp;&nbsp;状況の時呼ぶ．インタープリタはコアダンプし直ちに終了する．<br />
&nbsp;&nbsp;例外処理は一切行なわれない．<br />
<br />
**&nbsp;Rubyの初期化・実行<br />
<br />
Rubyをアプリケーションに埋め込む場合には以下のインタフェース<br />
を使う．通常の拡張ライブラリには必要ない．<br />
<br />
void&nbsp;ruby_init()<br />
<br />
&nbsp;&nbsp;Rubyインタプリタの初期化を行なう．<br />
<br />
void&nbsp;ruby_options(int&nbsp;argc,&nbsp;char&nbsp;**argv)<br />
<br />
&nbsp;&nbsp;Rubyインタプリタのコマンドライン引数の処理を行なう．<br />
<br />
void&nbsp;ruby_run()<br />
<br />
&nbsp;&nbsp;Rubyインタプリタを実行する．<br />
<br />
void&nbsp;ruby_script(char&nbsp;*name)<br />
<br />
&nbsp;&nbsp;Rubyのスクリプト名($0)を設定する．<br />
<br />
**&nbsp;インタプリタのイベントのフック<br />
<br />
&nbsp;void&nbsp;rb_add_event_hook(rb_event_hook_func_t&nbsp;func,&nbsp;rb_event_t&nbsp;events)<br />
<br />
指定されたインタプリタのイベントに対するフック関数を追加します．<br />
eventsは以下の値のorでなければなりません:<br />
<br />
&nbsp;&nbsp;RUBY_EVENT_LINE<br />
&nbsp;&nbsp;RUBY_EVENT_CLASS<br />
&nbsp;&nbsp;RUBY_EVENT_END<br />
&nbsp;&nbsp;RUBY_EVENT_CALL<br />
&nbsp;&nbsp;RUBY_EVENT_RETURN<br />
&nbsp;&nbsp;RUBY_EVENT_C_CALL<br />
&nbsp;&nbsp;RUBY_EVENT_C_RETURN<br />
&nbsp;&nbsp;RUBY_EVENT_RAISE<br />
&nbsp;&nbsp;RUBY_EVENT_ALL<br />
<br />
rb_event_hook_func_tの定義は以下の通りです:<br />
<br />
&nbsp;typedef&nbsp;void&nbsp;(*rb_event_hook_func_t)(rb_event_t&nbsp;event,&nbsp;NODE&nbsp;*node,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUE&nbsp;self,&nbsp;ID&nbsp;id,&nbsp;VALUE&nbsp;klass)<br />
<br />
&nbsp;int&nbsp;rb_remove_event_hook(rb_event_hook_func_t&nbsp;func)<br />
<br />
指定されたフック関数を削除します．<br />
<br />
<br />
Appendix&nbsp;C.&nbsp;extconf.rbで使える関数たち<br />
<br />
extconf.rbの中では利用可能なコンパイル条件チェックの関数は以<br />
下の通りである．<br />
<br />
have_macro(macro,&nbsp;headers)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードしてマクロmacroが定義さ<br />
&nbsp;&nbsp;れているかどうかチェックする．マクロが定義されている時true<br />
&nbsp;&nbsp;を返す．<br />
<br />
have_library(lib,&nbsp;func)<br />
<br />
&nbsp;&nbsp;関数funcを定義しているライブラリlibの存在をチェックする．<br />
&nbsp;&nbsp;ライブラリが存在する時，trueを返す．<br />
<br />
find_library(lib,&nbsp;func,&nbsp;path...)<br />
<br />
&nbsp;&nbsp;関数funcを定義しているライブラリlibの存在を&nbsp;-Lpath&nbsp;を追加<br />
&nbsp;&nbsp;しながらチェックする．ライブラリが見付かった時，trueを返す．<br />
<br />
have_func(func,&nbsp;header)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードして関数funcの存在をチェッ<br />
&nbsp;&nbsp;クする．funcが標準ではリンクされないライブラリ内のものであ<br />
&nbsp;&nbsp;る時には先にhave_libraryでそのライブラリをチェックしておく<br />
&nbsp;&nbsp;事．関数が存在する時trueを返す．<br />
<br />
have_var(var,&nbsp;header)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードして変数varの存在をチェッ<br />
&nbsp;&nbsp;クする．varが標準ではリンクされないライブラリ内のものであ<br />
&nbsp;&nbsp;る時には先にhave_libraryでそのライブラリをチェックしておく<br />
&nbsp;&nbsp;事．変数が存在する時trueを返す．<br />
<br />
have_header(header)<br />
<br />
&nbsp;&nbsp;ヘッダファイルの存在をチェックする．ヘッダファイルが存在す<br />
&nbsp;&nbsp;る時trueを返す．<br />
<br />
find_header(header,&nbsp;path...)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderの存在を&nbsp;-Ipath&nbsp;を追加しながらチェック<br />
&nbsp;&nbsp;する．ヘッダファイルが見付かった時，trueを返す．<br />
<br />
have_struct_member(type,&nbsp;member,&nbsp;header)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードして型typeにメンバmember<br />
&nbsp;&nbsp;が存在するかをチェックする．typeが定義されていて，memberを<br />
&nbsp;&nbsp;持つする時trueを返す．<br />
<br />
have_type(type,&nbsp;header,&nbsp;opt)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードして型typeが存在するかを<br />
&nbsp;&nbsp;チェックする．typeが定義されている時trueを返す．<br />
<br />
check_sizeof(type,&nbsp;header)<br />
<br />
&nbsp;&nbsp;ヘッダファイルheaderをインクルードして型typeのchar単位サイ<br />
&nbsp;&nbsp;ズを調べる．typeが定義されている時そのサイズを返す．定義さ<br />
&nbsp;&nbsp;れていないときはnilを返す．<br />
<br />
create_makefile(target)<br />
<br />
&nbsp;&nbsp;拡張ライブラリ用のMakefileを生成する．この関数を呼ばなけれ<br />
&nbsp;&nbsp;ばそのライブラリはコンパイルされない．targetはモジュール名<br />
&nbsp;&nbsp;を表す．<br />
<br />
find_executable(command,&nbsp;path)<br />
<br />
&nbsp;&nbsp;コマンドcommandをFile::PATH_SEPARATORで区切られたパス名の<br />
&nbsp;&nbsp;リストpathから探す．pathがnilまたは省略された場合は，環境<br />
&nbsp;&nbsp;変数PATHの値を使用する．実行可能なコマンドが見つかった場合<br />
&nbsp;&nbsp;はパスを含むファイル名，見つからなかった場合はnilを返す．<br />
<br />
with_config(withval[,&nbsp;default=nil])<br />
<br />
&nbsp;&nbsp;コマンドライン上の--with-&lt;withval&gt;で指定されたオプション値を得る．<br />
<br />
enable_config(config,&nbsp;*defaults)<br />
disable_config(config,&nbsp;*defaults)<br />
<br />
&nbsp;&nbsp;コマンドライン上の--enable-&lt;config&gt;または<br />
&nbsp;&nbsp;--disable-&lt;config&gt;で指定された真偽値を得る．<br />
&nbsp;&nbsp;--enable-&lt;config&gt;が指定されていた場合はtrue，<br />
&nbsp;&nbsp;--disable-&lt;config&gt;が指定されていた場合はfalseを返す．<br />
&nbsp;&nbsp;どちらも指定されていない場合は，ブロックつきで呼び出されている場合は<br />
&nbsp;&nbsp;*defaultsをyieldした結果，ブロックなしなら*defaultsを返す．<br />
<br />
dir_config(target[,&nbsp;default_dir])<br />
dir_config(target[,&nbsp;default_include,&nbsp;default_lib])<br />
<br />
&nbsp;&nbsp;コマンドライン上の--with-&lt;target&gt;-dir,&nbsp;--with-&lt;target&gt;-include,<br />
&nbsp;&nbsp;--with-&lt;target&gt;-libのいずれかで指定されるディレクトリを<br />
&nbsp;&nbsp;$CFLAGS&nbsp;や&nbsp;$LDFLAGS&nbsp;に追加する．--with-&lt;target&gt;-dir=/pathは<br />
&nbsp;&nbsp;--with-&lt;target&gt;-include=/path/include&nbsp;--with-&lt;target&gt;-lib=/path/lib<br />
&nbsp;&nbsp;と等価である．追加された&nbsp;include&nbsp;ディレクトリと&nbsp;lib&nbsp;ディレクトリの<br />
&nbsp;&nbsp;配列を返す．&nbsp;([include_dir,&nbsp;lib_dir])<br />
<br />
pkg_config(pkg)<br />
<br />
&nbsp;&nbsp;pkg-configコマンドからパッケージpkgの情報を得る．&nbsp;<br />
&nbsp;&nbsp;pkg-configの実際のコマンド名は，--with-pkg-configコマンド<br />
&nbsp;&nbsp;ラインオプションで指定可能．<br />
<br />
/*<br />
&nbsp;*&nbsp;Local&nbsp;variables:<br />
&nbsp;*&nbsp;fill-column:&nbsp;60<br />
&nbsp;*&nbsp;end:<br />
&nbsp;*/<br />


<hr />
<div class="navigator"><span class="navigator">[<a href="index.html">MAIN</a>][<a href="refm539.html">INDEX</a>]&nbsp;&nbsp;&nbsp;[<a href="index.html">TOP</a>][<a href="index.html">UP</a>][<a href="refm532.html">&lt;-PREV</a>][<a href="refm534.html">NEXT-&gt;</a>]</span></div>

</body>
</html>
